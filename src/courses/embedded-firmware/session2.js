export const session2 = {
    title: "Understanding MCU Architecture & Memory Map",
    content: `<style>.firmware-lesson{padding:0;margin:0}.firmware-lesson h2{color:#e74c3c;margin-top:40px;margin-bottom:20px;font-size:1.8em;border-left:5px solid #e74c3c;padding-left:15px}.hero-box{background:linear-gradient(135deg,rgba(231,76,60,0.1) 0%,rgba(192,57,43,0.1) 100%);border-radius:15px;padding:30px;margin:30px 0;text-align:center;border:2px solid rgba(231,76,60,0.2)}.info-box{background:#f8f9fa;border-left:5px solid #e74c3c;padding:20px;margin:25px 0;border-radius:8px}.cards-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:20px;margin:25px 0}.info-card{background:linear-gradient(135deg,rgba(231,76,60,0.08) 0%,rgba(192,57,43,0.08) 100%);padding:25px;border-radius:12px;border:2px solid rgba(231,76,60,0.2);transition:all 0.3s ease}.info-card:hover{transform:translateY(-5px);box-shadow:0 10px 25px rgba(231,76,60,0.2)}.card-icon{font-size:50px;margin-bottom:15px;display:block}.info-card h4{color:#e74c3c;margin-bottom:10px;font-size:1.2em}.firmware-lesson p{color:#333;margin-bottom:15px;font-size:1.05em;line-height:1.7}.firmware-lesson ul{margin:15px 0 15px 25px}.code-box{background:#1e1e1e;color:#d4d4d4;padding:20px;border-radius:10px;margin:20px 0;font-family:monospace;overflow-x:auto;font-size:14px}.quiz-box{background:#fff9e6;padding:25px;border-radius:15px;margin-top:30px;border:3px solid #ffd700}.fun-fact{background:#e8f5e9;border-left:5px solid #4caf50;padding:20px;margin:25px 0;border-radius:8px}</style><div class="firmware-lesson"><div class="hero-box"><div style="font-size:60px;margin-bottom:15px">ğŸ—ºï¸</div><p>Memory Map: Understanding where everything lives in your microcontroller!</p></div><h2>ğŸ›ï¸ Von Neumann vs Harvard Architecture</h2><div class="cards-grid"><div class="info-card"><span class="card-icon">ğŸ“š</span><h4>Von Neumann</h4><p>Single memory space for code and data. Simpler but slower.</p></div><div class="info-card"><span class="card-icon">ğŸ”€</span><h4>Harvard</h4><p>Separate memory for code and data. Faster, used in most MCUs!</p></div></div><div class="info-box"><strong>ARM Cortex-M uses Modified Harvard Architecture:</strong><ul><li>Separate buses for instruction and data access</li><li>Unified address space (appears as one memory map)</li><li>Can execute code from RAM or Flash</li><li>Best of both worlds!</li></ul></div><h2>ğŸ—ºï¸ Memory Map Overview (STM32F4 Example)</h2><div class="code-box">ARM Cortex-M Memory Map (4GB Address Space)<br><br>0x0000 0000 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”<br>             â”‚  Code Region            â”‚<br>             â”‚  (Flash aliased here)   â”‚<br>0x1FFF FFFF â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤<br>0x2000 0000 â”‚  SRAM Region            â”‚<br>             â”‚  (RAM for data/stack)   â”‚<br>0x3FFF FFFF â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤<br>0x4000 0000 â”‚  Peripheral Region      â”‚<br>             â”‚  (Memory-mapped I/O)    â”‚<br>0x5FFF FFFF â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤<br>             â”‚  External RAM           â”‚<br>0x9FFF FFFF â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤<br>             â”‚  External Devices       â”‚<br>0xDFFF FFFF â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤<br>0xE000 0000 â”‚  System Region          â”‚<br>             â”‚  (NVIC, SysTick, etc)   â”‚<br>0xFFFF FFFF â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</div><h2>ğŸ’¾ Flash Memory Region</h2><div class="info-box"><strong>Flash Memory (Non-volatile):</strong><ul><li><strong>Address:</strong> 0x0800 0000 (STM32F4)</li><li><strong>Size:</strong> 512KB - 2MB (depends on MCU)</li><li><strong>Purpose:</strong> Store your program code and constants</li><li><strong>Characteristics:</strong> Read-only at runtime, survives power-off</li><li><strong>Sectors:</strong> Divided into erasable sectors</li></ul></div><div class="code-box">// Flash memory layout example (STM32F407)<br><br>0x0800 0000  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”<br>             â”‚  Vector Table    â”‚  (First 1KB)<br>0x0800 0400  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤<br>             â”‚  .text section   â”‚  (Your code)<br>             â”‚  .rodata section â”‚  (Constants)<br>             â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤<br>             â”‚  .data initial   â”‚  (Init values)<br>0x080X XXXX  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  (End of Flash)</div><h2>ğŸ¯ SRAM Region</h2><div class="info-box"><strong>SRAM (Volatile RAM):</strong><ul><li><strong>Address:</strong> 0x2000 0000</li><li><strong>Size:</strong> 128KB - 256KB (depends on MCU)</li><li><strong>Purpose:</strong> Variables, stack, heap</li><li><strong>Characteristics:</strong> Fast read/write, lost on power-off</li><li><strong>Sections:</strong> .data, .bss, stack, heap</li></ul></div><div class="code-box">// SRAM layout<br><br>0x2000 0000  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”<br>             â”‚  .data section   â”‚  (Initialized variables)<br>             â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤<br>             â”‚  .bss section    â”‚  (Uninitialized variables)<br>             â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤<br>             â”‚  Heap â†“          â”‚  (Dynamic allocation)<br>             â”‚                  â”‚<br>             â”‚                  â”‚<br>             â”‚  Stack â†‘         â”‚  (Function calls, locals)<br>0x2001 FFFF  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  (End of SRAM)</div><h2>ğŸ”Œ Peripheral Region</h2><p>This is where <strong>Memory-Mapped I/O (MMIO)</strong> happens! Peripherals are accessed like memory.</p><div class="code-box">// Peripheral base addresses (STM32F4)<br><br>0x4000 0000  APB1 Peripherals<br>             â”œâ”€ TIM2-7, TIM12-14<br>             â”œâ”€ RTC, WWDG, IWDG<br>             â”œâ”€ SPI2/3, I2S2/3<br>             â”œâ”€ USART2/3, UART4/5<br>             â”œâ”€ I2C1/2/3<br>             â”œâ”€ CAN1/2<br>             â””â”€ PWR, DAC<br><br>0x4001 0000  APB2 Peripherals<br>             â”œâ”€ TIM1, TIM8-11<br>             â”œâ”€ USART1, USART6<br>             â”œâ”€ ADC1/2/3<br>             â”œâ”€ SPI1, SPI4<br>             â””â”€ SYSCFG, EXTI<br><br>0x4002 0000  AHB1 Peripherals<br>             â”œâ”€ GPIOA-K<br>             â”œâ”€ CRC, RCC<br>             â”œâ”€ DMA1/2<br>             â””â”€ Ethernet MAC<br><br>0x5000 0000  AHB2 Peripherals<br>             â””â”€ USB OTG FS, DCMI, RNG</div><h2>ğŸ“ Memory-Mapped I/O Concept</h2><div class="info-box"><strong>Key Concept:</strong> Peripherals are controlled by reading/writing to specific memory addresses!</div><div class="code-box">// Example: GPIOA registers<br><br>#define GPIOA_BASE    0x40020000<br><br>// Register offsets from base<br>#define MODER_OFFSET  0x00  // Mode register<br>#define ODR_OFFSET    0x14  // Output data register<br>#define IDR_OFFSET    0x10  // Input data register<br><br>// Full addresses<br>#define GPIOA_MODER   (*(volatile uint32_t*)(GPIOA_BASE + 0x00))<br>#define GPIOA_ODR     (*(volatile uint32_t*)(GPIOA_BASE + 0x14))<br>#define GPIOA_IDR     (*(volatile uint32_t*)(GPIOA_BASE + 0x10))<br><br>// Usage<br>GPIOA_MODER |= (1 << 10);  // Set PA5 as output<br>GPIOA_ODR |= (1 << 5);     // Set PA5 high</div><h2>ğŸ¯ System Region</h2><div class="info-box"><strong>System Control Block (0xE000 0000):</strong><ul><li><strong>NVIC:</strong> Nested Vectored Interrupt Controller</li><li><strong>SysTick:</strong> System timer</li><li><strong>SCB:</strong> System Control Block</li><li><strong>MPU:</strong> Memory Protection Unit</li><li><strong>FPU:</strong> Floating Point Unit (if present)</li></ul></div><div class="code-box">// Important system addresses<br><br>0xE000E000  SysTick<br>0xE000E100  NVIC (Interrupt controller)<br>0xE000ED00  SCB (System Control Block)<br>0xE000ED90  MPU (Memory Protection Unit)<br>0xE000EF00  FPU (Floating Point Unit)</div><h2>ğŸ“Š Memory Access Permissions</h2><div class="cards-grid"><div class="info-card"><span class="card-icon">âœ…</span><h4>Flash (Code)</h4><p>Read: âœ“ Write: âœ— Execute: âœ“</p></div><div class="info-card"><span class="card-icon">âœ…</span><h4>SRAM</h4><p>Read: âœ“ Write: âœ“ Execute: âœ“*</p></div><div class="info-card"><span class="card-icon">âš™ï¸</span><h4>Peripherals</h4><p>Read: âœ“ Write: âœ“ Execute: âœ—</p></div><div class="info-card"><span class="card-icon">ğŸ”’</span><h4>System</h4><p>Privileged access only</p></div></div><div class="fun-fact"><strong>ğŸŒŸ Fun Fact:</strong><p style="margin-top:10px;margin-bottom:0">The entire 4GB address space is mapped even though your MCU might only have 512KB Flash and 128KB RAM! Accessing unmapped regions causes a HardFault exception. This is actually useful for catching bugs!</p></div><div class="quiz-box"><h3>ğŸ§  Test Your Knowledge!</h3><p><strong>Question:</strong> What is the Flash memory base address on STM32F4?</p><ul><li>A) 0x0000 0000</li><li>B) 0x0800 0000 âœ“</li><li>C) 0x2000 0000</li><li>D) 0x4000 0000</li></ul><p style="margin-top:15px"><em>Answer: B - Flash starts at 0x0800 0000 on STM32F4!</em></p></div></div>`,
    questions: [{ q: "What is the Flash memory base address on STM32F4?", options: ["0x0000 0000", "0x0800 0000", "0x2000 0000", "0x4000 0000"], answer: 1 }],
    tools: [{ name: "Memory Map Explorer", type: "interactive", description: "Visualize MCU memory regions" }]
};
