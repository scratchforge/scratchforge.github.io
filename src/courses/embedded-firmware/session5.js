export const session5 = {
    title: "Understanding ELF Files and Binary Formats",
    content: `<style>.firmware-lesson{padding:0;margin:0}.firmware-lesson h2{color:#e74c3c;margin-top:40px;margin-bottom:20px;font-size:1.8em;border-left:5px solid #e74c3c;padding-left:15px}.hero-box{background:linear-gradient(135deg,rgba(231,76,60,0.1) 0%,rgba(192,57,43,0.1) 100%);border-radius:15px;padding:30px;margin:30px 0;text-align:center;border:2px solid rgba(231,76,60,0.2)}.info-box{background:#f8f9fa;border-left:5px solid #e74c3c;padding:20px;margin:25px 0;border-radius:8px}.cards-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:20px;margin:25px 0}.info-card{background:linear-gradient(135deg,rgba(231,76,60,0.08) 0%,rgba(192,57,43,0.08) 100%);padding:25px;border-radius:12px;border:2px solid rgba(231,76,60,0.2);transition:all 0.3s ease}.info-card:hover{transform:translateY(-5px);box-shadow:0 10px 25px rgba(231,76,60,0.2)}.card-icon{font-size:50px;margin-bottom:15px;display:block}.info-card h4{color:#e74c3c;margin-bottom:10px;font-size:1.2em}.firmware-lesson p{color:#333;margin-bottom:15px;font-size:1.05em;line-height:1.7}.firmware-lesson ul{margin:15px 0 15px 25px}.code-box{background:#1e1e1e;color:#d4d4d4;padding:20px;border-radius:10px;margin:20px 0;font-family:monospace;overflow-x:auto;font-size:14px}.quiz-box{background:#fff9e6;padding:25px;border-radius:15px;margin-top:30px;border:3px solid #ffd700}.fun-fact{background:#e8f5e9;border-left:5px solid #4caf50;padding:20px;margin:25px 0;border-radius:8px}</style><div class="firmware-lesson"><div class="hero-box"><div style="font-size:60px;margin-bottom:15px">ğŸ“¦</div><p>ELF Files: Understanding the executable format for embedded systems!</p></div><h2>ğŸ“„ What is an ELF File?</h2><p><strong>ELF (Executable and Linkable Format)</strong> is the standard binary format for executables, object files, and libraries on Unix-like systems and embedded ARM processors.</p><div class="info-box"><strong>ELF File Types:</strong><ul><li><strong>Relocatable (.o):</strong> Object files from compilation</li><li><strong>Executable (.elf):</strong> Linked executable program</li><li><strong>Shared Object (.so):</strong> Shared libraries (not used in bare-metal)</li></ul></div><h2>ğŸ—ï¸ ELF File Structure</h2><div class="code-box">ELF File Layout:<br><br>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”<br>â”‚  ELF Header         â”‚  File type, architecture, entry point<br>â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤<br>â”‚  Program Headers    â”‚  Segments for loading (runtime view)<br>â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤<br>â”‚  Section Headers    â”‚  Sections for linking (link-time view)<br>â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤<br>â”‚  .text section      â”‚  Executable code<br>â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤<br>â”‚  .rodata section    â”‚  Read-only data (constants)<br>â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤<br>â”‚  .data section      â”‚  Initialized data<br>â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤<br>â”‚  .bss section       â”‚  Uninitialized data<br>â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤<br>â”‚  .symtab section    â”‚  Symbol table<br>â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤<br>â”‚  .strtab section    â”‚  String table<br>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</div><h2>ğŸ” Inspecting ELF Files</h2><div class="code-box"># View ELF header<br>arm-none-eabi-readelf -h firmware.elf<br><br># Output:<br>ELF Header:<br>  Magic:   7f 45 4c 46 01 01 01 00<br>  Class:                             ELF32<br>  Data:                              2's complement, little endian<br>  Machine:                           ARM<br>  Entry point address:               0x8000189<br>  Start of program headers:          52 (bytes into file)<br>  Start of section headers:          12345 (bytes into file)</div><h2>ğŸ“Š Sections vs Segments</h2><div class="cards-grid"><div class="info-card"><span class="card-icon">ğŸ“</span><h4>Sections</h4><p>Link-time view - for linker and debugger</p></div><div class="info-card"><span class="card-icon">ğŸš€</span><h4>Segments</h4><p>Run-time view - for loader (what goes in memory)</p></div></div><div class="code-box"># View sections<br>arm-none-eabi-objdump -h firmware.elf<br><br># View segments<br>arm-none-eabi-readelf -l firmware.elf<br><br># View section sizes<br>arm-none-eabi-size firmware.elf<br>   text    data     bss     dec     hex filename<br>   4096     256    1024    5376    1500 firmware.elf</div><h2>ğŸ”§ Common ELF Tools</h2><div class="code-box"># objdump - Disassemble and inspect<br>arm-none-eabi-objdump -d firmware.elf > disassembly.txt<br>arm-none-eabi-objdump -t firmware.elf  # Symbol table<br>arm-none-eabi-objdump -x firmware.elf  # All headers<br><br># nm - List symbols<br>arm-none-eabi-nm firmware.elf<br>08000000 T Reset_Handler<br>20000000 B _sbss<br>20001000 D _sdata<br><br># size - Memory usage<br>arm-none-eabi-size -A firmware.elf  # Detailed<br>arm-none-eabi-size -B firmware.elf  # Berkeley format</div><h2>ğŸ”„ Converting ELF to Other Formats</h2><div class="info-box"><strong>Why convert?</strong> Flash programmers often need raw binary or Intel HEX format instead of ELF.</div><div class="code-box"># Convert to binary (.bin)<br>arm-none-eabi-objcopy -O binary firmware.elf firmware.bin<br><br># Convert to Intel HEX (.hex)<br>arm-none-eabi-objcopy -O ihex firmware.elf firmware.hex<br><br># Extract specific section<br>arm-none-eabi-objcopy -O binary --only-section=.text firmware.elf text.bin</div><h2>ğŸ“‹ Binary Format Comparison</h2><div class="cards-grid"><div class="info-card"><span class="card-icon">ğŸ“¦</span><h4>.ELF</h4><p>Full debug info, symbols, sections</p></div><div class="info-card"><span class="card-icon">ğŸ’¾</span><h4>.BIN</h4><p>Raw binary, no metadata, smallest</p></div><div class="info-card"><span class="card-icon">ğŸ“„</span><h4>.HEX</h4><p>ASCII format with addresses, portable</p></div></div><div class="code-box"># .bin file - Raw bytes<br>08 00 00 20 89 01 00 08 ...<br><br># .hex file - Intel HEX format<br>:10000000080000208901000800000000000000009A<br>:10001000000000000000000000000000000000000<br>:00000001FF<br><br>Format: :LLAAAATT[DD...]CC<br>  LL = Length<br>  AAAA = Address<br>  TT = Type (00=data, 01=EOF)<br>  DD = Data bytes<br>  CC = Checksum</div><h2>ğŸ¯ LMA vs VMA</h2><div class="info-box"><strong>Critical Concept for Embedded:</strong><ul><li><strong>LMA (Load Memory Address):</strong> Where data is stored in Flash</li><li><strong>VMA (Virtual Memory Address):</strong> Where data runs in RAM</li></ul><p style="margin-top:10px">Example: .data section has LMA in Flash but VMA in RAM. Startup code copies it!</p></div><div class="code-box"># View LMA and VMA<br>arm-none-eabi-objdump -h firmware.elf<br><br>Sections:<br>Idx Name      Size      VMA       LMA       File off<br>  0 .text     00001000  08000000  08000000  00010000<br>  1 .data     00000100  20000000  08001000  00020000<br>  2 .bss      00000400  20000100  20000100  00000000<br><br># .data: VMA=0x20000000 (RAM), LMA=0x08001000 (Flash)</div><h2>ğŸ” Analyzing Memory Usage</h2><div class="code-box"># Detailed size analysis<br>arm-none-eabi-size -A -x firmware.elf<br><br>firmware.elf  :<br>section           size       addr<br>.isr_vector      0x188   0x8000000<br>.text           0x1e50   0x8000188<br>.rodata          0x100   0x8001fd8<br>.data             0x20  0x20000000<br>.bss             0x400  0x20000020<br><br># Calculate Flash usage: .text + .rodata + .data (LMA)<br># Calculate RAM usage: .data + .bss</div><div class="fun-fact"><strong>ğŸŒŸ ELF Magic:</strong><p style="margin-top:10px;margin-bottom:0">Every ELF file starts with the magic bytes: 7F 45 4C 46 (0x7F followed by 'ELF' in ASCII). This is how the system identifies it as an ELF file. The format was designed in the 1990s and is still the standard today!</p></div><div class="quiz-box"><h3>ğŸ§  Test Your Knowledge!</h3><p><strong>Question:</strong> What does LMA stand for?</p><ul><li>A) Link Memory Address</li><li>B) Load Memory Address âœ“</li><li>C) Local Memory Access</li><li>D) Logical Memory Allocation</li></ul><p style="margin-top:15px"><em>Answer: B - LMA is where data is stored in Flash!</em></p></div></div>`,
    questions: [{ q: "What does LMA stand for?", options: ["Link Memory Address", "Load Memory Address", "Local Memory Access", "Logical Memory Allocation"], answer: 1 }],
    tools: [{ name: "ELF Inspector", type: "interactive", description: "Explore ELF file structure" }]
};
