export const session9 = {
    title: "Memory Sections (.text, .data, .bss, .rodata)",
    content: `<style>.firmware-lesson{padding:0;margin:0}.firmware-lesson h2{color:#e74c3c;margin-top:40px;margin-bottom:20px;font-size:1.8em;border-left:5px solid #e74c3c;padding-left:15px}.hero-box{background:linear-gradient(135deg,rgba(231,76,60,0.1) 0%,rgba(192,57,43,0.1) 100%);border-radius:15px;padding:30px;margin:30px 0;text-align:center;border:2px solid rgba(231,76,60,0.2)}.info-box{background:#f8f9fa;border-left:5px solid #e74c3c;padding:20px;margin:25px 0;border-radius:8px}.cards-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:20px;margin:25px 0}.info-card{background:linear-gradient(135deg,rgba(231,76,60,0.08) 0%,rgba(192,57,43,0.08) 100%);padding:25px;border-radius:12px;border:2px solid rgba(231,76,60,0.2);transition:all 0.3s ease}.info-card:hover{transform:translateY(-5px);box-shadow:0 10px 25px rgba(231,76,60,0.2)}.card-icon{font-size:50px;margin-bottom:15px;display:block}.info-card h4{color:#e74c3c;margin-bottom:10px;font-size:1.2em}.firmware-lesson p{color:#333;margin-bottom:15px;font-size:1.05em;line-height:1.7}.firmware-lesson ul{margin:15px 0 15px 25px}.code-box{background:#1e1e1e;color:#d4d4d4;padding:20px;border-radius:10px;margin:20px 0;font-family:monospace;overflow-x:auto;font-size:14px}.quiz-box{background:#fff9e6;padding:25px;border-radius:15px;margin-top:30px;border:3px solid #ffd700}.fun-fact{background:#e8f5e9;border-left:5px solid #4caf50;padding:20px;margin:25px 0;border-radius:8px}</style><div class="firmware-lesson"><div class="hero-box"><div style="font-size:60px;margin-bottom:15px">ğŸ“¦</div><p>Memory Sections: Organizing your code and data in Flash and RAM!</p></div><h2>ğŸ—‚ï¸ The Four Main Sections</h2><div class="cards-grid"><div class="info-card"><span class="card-icon">.text</span><h4>Code Section</h4><p>Executable instructions in Flash</p></div><div class="info-card"><span class="card-icon">.rodata</span><h4>Read-Only Data</h4><p>Constants in Flash</p></div><div class="info-card"><span class="card-icon">.data</span><h4>Initialized Data</h4><p>Variables with initial values in RAM</p></div><div class="info-card"><span class="card-icon">.bss</span><h4>Uninitialized Data</h4><p>Zero-initialized variables in RAM</p></div></div><h2>ğŸ’¾ .text Section (Code)</h2><div class="info-box"><strong>.text Section:</strong><ul><li>Contains executable code</li><li>Stored in Flash memory</li><li>Read-only at runtime</li><li>Includes all functions</li></ul></div><div class="code-box">// All functions go in .text<br>void delay(uint32_t ms) {<br>    for(uint32_t i = 0; i < ms * 1000; i++);<br>}<br><br>int main(void) {<br>    delay(100);<br>    return 0;<br>}<br><br>// In linker script:<br>.text : {<br>    *(.text)    /* All code */<br>    *(.text*)   /* All .text.* sections */<br>} > FLASH</div><h2>ğŸ“– .rodata Section (Read-Only Data)</h2><div class="info-box"><strong>.rodata Section:</strong><ul><li>Constants and string literals</li><li>Stored in Flash memory</li><li>Never changes at runtime</li><li>Saves RAM!</li></ul></div><div class="code-box">// String literals â†’ .rodata<br>const char* message = "Hello World";<br><br>// Const arrays â†’ .rodata<br>const uint8_t lookup_table[] = {0, 1, 2, 3, 4};<br><br>// Const structs â†’ .rodata<br>const struct {<br>    uint32_t id;<br>    const char* name;<br>} device = {1, "STM32F407"};<br><br>// In linker script:<br>.rodata : {<br>    *(.rodata)<br>    *(.rodata*)<br>} > FLASH</div><h2>ğŸ’¾ .data Section (Initialized Variables)</h2><div class="info-box"><strong>.data Section:</strong><ul><li>Global/static variables with initial values</li><li>Stored in Flash (LMA) but runs in RAM (VMA)</li><li>Copied from Flash to RAM at startup</li><li>Uses both Flash AND RAM!</li></ul></div><div class="code-box">// Initialized global â†’ .data<br>uint32_t counter = 100;<br><br>// Initialized static â†’ .data<br>static uint8_t state = 5;<br><br>// Initialized array â†’ .data<br>int numbers[5] = {1, 2, 3, 4, 5};<br><br>// In linker script:<br>.data : {<br>    _sdata = .;         /* Start marker */<br>    *(.data)<br>    *(.data*)<br>    _edata = .;         /* End marker */<br>} > RAM AT> FLASH<br><br>/* Startup code copies .data from Flash to RAM */<br>_sidata = LOADADDR(.data);  /* Source in Flash */</div><h2>ğŸ—‘ï¸ .bss Section (Uninitialized Variables)</h2><div class="info-box"><strong>.bss Section (Block Started by Symbol):</strong><ul><li>Uninitialized or zero-initialized variables</li><li>Only in RAM (no Flash storage!)</li><li>Zeroed by startup code</li><li>Saves Flash space!</li></ul></div><div class="code-box">// Uninitialized global â†’ .bss<br>uint32_t buffer[256];<br><br>// Zero-initialized â†’ .bss<br>static int value = 0;<br><br>// Uninitialized static â†’ .bss<br>static uint8_t data;<br><br>// In linker script:<br>.bss : {<br>    _sbss = .;          /* Start marker */<br>    *(.bss)<br>    *(.bss*)<br>    *(COMMON)<br>    _ebss = .;          /* End marker */<br>} > RAM<br><br>/* Startup code zeros .bss */</div><h2>ğŸ“Š Memory Usage Comparison</h2><div class="code-box">// Example variables<br>const int a = 10;           // .rodata (Flash only)<br>int b = 20;                 // .data (Flash + RAM)<br>int c;                      // .bss (RAM only)<br>static int d = 30;          // .data (Flash + RAM)<br>static int e;               // .bss (RAM only)<br><br>void func(void) {<br>    int local = 40;         // Stack (RAM, not a section)<br>    static int s = 50;      // .data (Flash + RAM)<br>}<br><br>/* Memory usage:<br>   Flash: a + b + d + s = 4 variables<br>   RAM:   b + c + d + e + s + stack = 6 items<br>*/</div><h2>ğŸ¯ Section Attributes</h2><div class="code-box">// Place variable in specific section<br>__attribute__((section(".my_section")))<br>uint32_t special_var = 123;<br><br>// Place in .data even if const<br>__attribute__((section(".data")))<br>const uint32_t ram_const = 456;<br><br>// Align to specific boundary<br>__attribute__((aligned(16)))<br>uint8_t aligned_buffer[256];<br><br>// Combine attributes<br>__attribute__((section(".ccmram"), aligned(4)))<br>uint32_t ccm_data[128];</div><h2>ğŸ” Viewing Sections</h2><div class="code-box"># View section sizes<br>arm-none-eabi-size firmware.elf<br>   text    data     bss     dec     hex filename<br>   4096     256    1024    5376    1500 firmware.elf<br><br># Detailed section info<br>arm-none-eabi-size -A firmware.elf<br>firmware.elf  :<br>section       size      addr<br>.text         4096  0x8000000<br>.rodata        512  0x8001000<br>.data          256  0x20000000<br>.bss          1024  0x20000100<br><br># View section contents<br>arm-none-eabi-objdump -h firmware.elf<br>arm-none-eabi-objdump -s -j .rodata firmware.elf</div><h2>ğŸ’¡ Optimization Tips</h2><div class="info-box"><strong>Save Flash:</strong><ul><li>Use .bss instead of .data when possible (don't initialize to 0)</li><li>Use const for read-only data (moves to .rodata)</li><li>Minimize global variables</li></ul><strong>Save RAM:</strong><ul><li>Use const for constants (keeps in Flash)</li><li>Use static const for lookup tables</li><li>Consider code in Flash vs RAM tradeoff</li></ul></div><div class="code-box">// BAD: Uses Flash + RAM<br>uint8_t buffer[1024] = {0};<br><br>// GOOD: Uses only RAM (same result)<br>uint8_t buffer[1024];<br><br>// BAD: Uses RAM<br>uint8_t lookup[256] = {0,1,2,3,...};<br><br>// GOOD: Uses only Flash<br>const uint8_t lookup[256] = {0,1,2,3,...};</div><h2>ğŸ—ºï¸ Complete Memory Layout</h2><div class="code-box">FLASH (0x08000000)<br>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”<br>â”‚  .isr_vector     â”‚  Vector table<br>â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤<br>â”‚  .text           â”‚  Your code<br>â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤<br>â”‚  .rodata         â”‚  Constants<br>â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤<br>â”‚  .data (LMA)     â”‚  Initial values for .data<br>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜<br><br>RAM (0x20000000)<br>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”<br>â”‚  .data (VMA)     â”‚  Initialized variables<br>â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤<br>â”‚  .bss            â”‚  Uninitialized variables<br>â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤<br>â”‚  Heap â†“          â”‚  Dynamic allocation<br>â”‚                  â”‚<br>â”‚  Stack â†‘         â”‚  Function calls<br>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ _estack</div><div class="fun-fact"><strong>ğŸŒŸ BSS History:</strong><p style="margin-top:10px;margin-bottom:0">BSS stands for "Block Started by Symbol" from an old IBM assembler directive. The clever part: uninitialized data doesn't need to be stored in the executable file - just a note saying "reserve X bytes and zero them". This saves Flash space!</p></div><div class="quiz-box"><h3>ğŸ§  Test Your Knowledge!</h3><p><strong>Question:</strong> Which section uses both Flash AND RAM?</p><ul><li>A) .text</li><li>B) .rodata</li><li>C) .data âœ“</li><li>D) .bss</li></ul><p style="margin-top:15px"><em>Answer: C - .data is stored in Flash but copied to RAM at startup!</em></p></div></div>`,
    questions: [{ q: "Which section uses both Flash AND RAM?", options: [".text", ".rodata", ".data", ".bss"], answer: 2 }],
    tools: [{ name: "Section Analyzer", type: "interactive", description: "Analyze memory section usage" }]
};
