export const session3 = {
    title: "ARM Cortex-M Architecture Deep Dive",
    content: `<style>.firmware-lesson{padding:0;margin:0}.firmware-lesson h2{color:#e74c3c;margin-top:40px;margin-bottom:20px;font-size:1.8em;border-left:5px solid #e74c3c;padding-left:15px}.hero-box{background:linear-gradient(135deg,rgba(231,76,60,0.1) 0%,rgba(192,57,43,0.1) 100%);border-radius:15px;padding:30px;margin:30px 0;text-align:center;border:2px solid rgba(231,76,60,0.2)}.info-box{background:#f8f9fa;border-left:5px solid #e74c3c;padding:20px;margin:25px 0;border-radius:8px}.cards-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:20px;margin:25px 0}.info-card{background:linear-gradient(135deg,rgba(231,76,60,0.08) 0%,rgba(192,57,43,0.08) 100%);padding:25px;border-radius:12px;border:2px solid rgba(231,76,60,0.2);transition:all 0.3s ease}.info-card:hover{transform:translateY(-5px);box-shadow:0 10px 25px rgba(231,76,60,0.2)}.card-icon{font-size:50px;margin-bottom:15px;display:block}.info-card h4{color:#e74c3c;margin-bottom:10px;font-size:1.2em}.firmware-lesson p{color:#333;margin-bottom:15px;font-size:1.05em;line-height:1.7}.firmware-lesson ul{margin:15px 0 15px 25px}.code-box{background:#1e1e1e;color:#d4d4d4;padding:20px;border-radius:10px;margin:20px 0;font-family:monospace;overflow-x:auto;font-size:14px}.quiz-box{background:#fff9e6;padding:25px;border-radius:15px;margin-top:30px;border:3px solid #ffd700}.fun-fact{background:#e8f5e9;border-left:5px solid #4caf50;padding:20px;margin:25px 0;border-radius:8px}</style><div class="firmware-lesson"><div class="hero-box"><div style="font-size:60px;margin-bottom:15px">ðŸ§ </div><p>ARM Cortex-M: The brain of billions of embedded devices!</p></div><h2>ðŸŽ¯ Cortex-M Family Overview</h2><div class="cards-grid"><div class="info-card"><span class="card-icon">M0</span><h4>Cortex-M0/M0+</h4><p>Ultra-low power, simple, 32-bit RISC</p></div><div class="info-card"><span class="card-icon">M3</span><h4>Cortex-M3</h4><p>Balanced performance, no FPU</p></div><div class="info-card"><span class="card-icon">M4</span><h4>Cortex-M4</h4><p>DSP + optional FPU, most popular</p></div><div class="info-card"><span class="card-icon">M7</span><h4>Cortex-M7</h4><p>High performance, cache, FPU</p></div></div><h2>ðŸ“‹ Register Set (13 General + 3 Special)</h2><div class="code-box">ARM Cortex-M Registers:<br><br>R0  - R12   General Purpose Registers<br>            (R0-R3 for function arguments)<br>            (R0 for return value)<br><br>R13 (SP)    Stack Pointer<br>            - MSP: Main Stack Pointer<br>            - PSP: Process Stack Pointer<br><br>R14 (LR)    Link Register<br>            - Stores return address<br>            - Special values for exceptions<br><br>R15 (PC)    Program Counter<br>            - Points to next instruction<br>            - Always even (Thumb mode)<br><br>Special Registers:<br>PSR         Program Status Register<br>PRIMASK     Interrupt mask<br>FAULTMASK   Fault mask<br>BASEPRI     Base priority mask<br>CONTROL     Control register</div><h2>ðŸ”„ Operating Modes</h2><div class="info-box"><strong>Two Operating Modes:</strong><ul><li><strong>Thread Mode:</strong> Normal application code runs here</li><li><strong>Handler Mode:</strong> Exception/interrupt handlers run here</li></ul><strong>Two Privilege Levels:</strong><ul><li><strong>Privileged:</strong> Full access to all resources</li><li><strong>Unprivileged:</strong> Limited access (for OS tasks)</li></ul></div><div class="code-box">// CONTROL register bits<br><br>Bit 0: nPRIV<br>  0 = Privileged<br>  1 = Unprivileged<br><br>Bit 1: SPSEL (Stack Pointer Select)<br>  0 = MSP (Main Stack Pointer)<br>  1 = PSP (Process Stack Pointer)<br><br>Bit 2: FPCA (Floating Point Context Active)<br>  Only on Cortex-M4/M7 with FPU</div><h2>âš¡ NVIC - Nested Vectored Interrupt Controller</h2><p>The NVIC is the heart of exception handling in Cortex-M processors.</p><div class="info-box"><strong>NVIC Features:</strong><ul><li>Up to 240 external interrupts</li><li>16 priority levels (configurable 3-8 bits)</li><li>Nested interrupt support</li><li>Automatic state saving/restoring</li><li>Tail-chaining optimization</li><li>Late-arriving interrupt handling</li></ul></div><div class="code-box">// NVIC Register addresses<br><br>#define NVIC_ISER0  (*(volatile uint32_t*)0xE000E100)<br>#define NVIC_ICER0  (*(volatile uint32_t*)0xE000E180)<br>#define NVIC_ISPR0  (*(volatile uint32_t*)0xE000E200)<br>#define NVIC_ICPR0  (*(volatile uint32_t*)0xE000E280)<br>#define NVIC_IPR0   (*(volatile uint32_t*)0xE000E400)<br><br>// Enable interrupt 25 (USART1 on STM32)<br>NVIC_ISER0 |= (1 << 25);<br><br>// Set priority for interrupt 25 (priority 5)<br>NVIC_IPR0 |= (5 << 29);  // Bits 29-31 for IRQ 25</div><h2>ðŸŽ¯ Exception Model</h2><div class="code-box">Exception Numbers (First 16 are system exceptions):<br><br>0   -        (Reserved)<br>1   Reset    Reset handler<br>2   NMI      Non-Maskable Interrupt<br>3   HardFault Hard Fault<br>4   MemManage Memory Management Fault<br>5   BusFault  Bus Fault<br>6   UsageFault Usage Fault<br>7-10 -       (Reserved)<br>11  SVCall   Supervisor Call<br>12  Debug    Debug Monitor<br>13  -        (Reserved)<br>14  PendSV   Pendable Service Call<br>15  SysTick  System Tick Timer<br>16+ External External Interrupts (NVIC)</div><h2>ðŸ”¢ Priority Levels</h2><div class="info-box"><strong>Priority Rules:</strong><ul><li>Lower number = Higher priority</li><li>0 is highest priority</li><li>Negative priorities for system exceptions</li><li>Configurable priority bits (usually 4 bits = 16 levels)</li><li>Preemption and sub-priority grouping</li></ul></div><div class="code-box">// Priority grouping example<br><br>// 4 bits total: [7:4] used for priority<br>// Can split into preemption + sub-priority<br><br>Group 0: 0 bits preempt, 4 bits sub (no nesting)<br>Group 1: 1 bit preempt,  3 bits sub<br>Group 2: 2 bits preempt, 2 bits sub<br>Group 3: 3 bits preempt, 1 bit sub<br>Group 4: 4 bits preempt, 0 bits sub (full nesting)</div><h2>ðŸ’¾ Stack Operation</h2><div class="code-box">// Stack grows downward (from high to low addresses)<br><br>Exception Entry (Auto-saved by hardware):<br>  SP -= 32;  // Make space<br>  Push R0, R1, R2, R3, R12, LR, PC, xPSR<br><br>Exception Exit (Auto-restored):<br>  Pop R0, R1, R2, R3, R12, LR, PC, xPSR<br>  SP += 32;<br><br>// This is AUTOMATIC! No need to save/restore manually</div><h2>ðŸš€ Performance Features</h2><div class="cards-grid"><div class="info-card"><span class="card-icon">âš¡</span><h4>3-Stage Pipeline</h4><p>Fetch, Decode, Execute</p></div><div class="info-card"><span class="card-icon">ðŸŽ¯</span><h4>Single-cycle multiply</h4><p>Fast 32-bit multiplication</p></div><div class="info-card"><span class="card-icon">ðŸ”„</span><h4>Tail-chaining</h4><p>Fast back-to-back interrupts</p></div><div class="info-card"><span class="card-icon">ðŸ“Š</span><h4>Bit-banding</h4><p>Atomic bit operations</p></div></div><div class="fun-fact"><strong>ðŸŒŸ ARM Dominance:</strong><p style="margin-top:10px;margin-bottom:0">Over 150 billion ARM chips have been shipped! ARM Cortex-M processors power everything from tiny sensors to automotive systems. The architecture is so efficient that some Cortex-M0 chips run on just microamps!</p></div><div class="quiz-box"><h3>ðŸ§  Test Your Knowledge!</h3><p><strong>Question:</strong> What does the LR (Link Register) store?</p><ul><li>A) Current stack pointer</li><li>B) Return address âœ“</li><li>C) Interrupt priority</li><li>D) Program status</li></ul><p style="margin-top:15px"><em>Answer: B - LR stores the return address for function calls!</em></p></div></div>`,
    questions: [{ q: "What does the LR (Link Register) store?", options: ["Current stack pointer", "Return address", "Interrupt priority", "Program status"], answer: 1 }],
    tools: [{ name: "Register Viewer", type: "interactive", description: "Explore ARM registers" }]
};
