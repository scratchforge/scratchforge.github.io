export const session10 = {
    title: "Advanced Linker Script Techniques",
    content: `<style>.firmware-lesson{padding:0;margin:0}.firmware-lesson h2{color:#e74c3c;margin-top:40px;margin-bottom:20px;font-size:1.8em;border-left:5px solid #e74c3c;padding-left:15px}.hero-box{background:linear-gradient(135deg,rgba(231,76,60,0.1) 0%,rgba(192,57,43,0.1) 100%);border-radius:15px;padding:30px;margin:30px 0;text-align:center;border:2px solid rgba(231,76,60,0.2)}.info-box{background:#f8f9fa;border-left:5px solid #e74c3c;padding:20px;margin:25px 0;border-radius:8px}.cards-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:20px;margin:25px 0}.info-card{background:linear-gradient(135deg,rgba(231,76,60,0.08) 0%,rgba(192,57,43,0.08) 100%);padding:25px;border-radius:12px;border:2px solid rgba(231,76,60,0.2);transition:all 0.3s ease}.info-card:hover{transform:translateY(-5px);box-shadow:0 10px 25px rgba(231,76,60,0.2)}.card-icon{font-size:50px;margin-bottom:15px;display:block}.info-card h4{color:#e74c3c;margin-bottom:10px;font-size:1.2em}.firmware-lesson p{color:#333;margin-bottom:15px;font-size:1.05em;line-height:1.7}.firmware-lesson ul{margin:15px 0 15px 25px}.code-box{background:#1e1e1e;color:#d4d4d4;padding:20px;border-radius:10px;margin:20px 0;font-family:monospace;overflow-x:auto;font-size:14px}.quiz-box{background:#fff9e6;padding:25px;border-radius:15px;margin-top:30px;border:3px solid #ffd700}.fun-fact{background:#e8f5e9;border-left:5px solid #4caf50;padding:20px;margin:25px 0;border-radius:8px}</style><div class="firmware-lesson"><div class="hero-box"><div style="font-size:60px;margin-bottom:15px">üéì</div><p>Advanced Linker Techniques: Master memory layout control!</p></div><h2>üéØ LMA vs VMA Deep Dive</h2><div class="info-box"><strong>Key Concept:</strong><ul><li><strong>VMA (Virtual Memory Address):</strong> Where section runs</li><li><strong>LMA (Load Memory Address):</strong> Where section is stored</li><li>For .text and .rodata: VMA = LMA (runs from Flash)</li><li>For .data: VMA ‚â† LMA (stored in Flash, runs in RAM)</li></ul></div><div class="code-box">/* .data section example */<br>.data : {<br>    _sdata = .;         /* VMA start (RAM) */<br>    *(.data)<br>    _edata = .;         /* VMA end (RAM) */<br>} > RAM AT> FLASH<br><br>_sidata = LOADADDR(.data);  /* LMA (Flash) */<br><br>/* Startup code copies from LMA to VMA */<br>uint32_t *src = &_sidata;   /* Source: Flash (LMA) */<br>uint32_t *dst = &_sdata;    /* Dest: RAM (VMA) */<br>while (dst < &_edata) {<br>    *dst++ = *src++;<br>}</div><h2>üìç KEEP Directive</h2><div class="code-box">/* KEEP prevents garbage collection */<br><br>.isr_vector : {<br>    KEEP(*(.isr_vector))  /* Don't remove even if "unused" */<br>} > FLASH<br><br>/* Without KEEP, linker might remove:<br>   - Interrupt vectors<br>   - Startup code<br>   - Code called via function pointers<br>*/</div><h2>üîß PROVIDE and HIDDEN</h2><div class="code-box">/* PROVIDE - Define symbol if not already defined */<br>PROVIDE(__stack = _estack);<br>PROVIDE(end = _end);<br><br>/* HIDDEN - Symbol not exported */<br>HIDDEN(_internal_symbol = 0x20000000);<br><br>/* In C code: */<br>extern uint32_t __stack;  /* Can use if not defined elsewhere */</div><h2>üìè Alignment and Padding</h2><div class="code-box">/* ALIGN - Align location counter */<br>.text : {<br>    . = ALIGN(4);       /* Align to 4-byte boundary */<br>    *(.text)<br>    . = ALIGN(8);       /* Align to 8-byte boundary */<br>}<br><br>/* ALIGN with fill */<br>. = ALIGN(16);          /* Align and fill with zeros */<br>. = ALIGN(16, 0xFF);    /* Align and fill with 0xFF */<br><br>/* ALIGNOF - Get alignment of section */<br>_text_align = ALIGNOF(.text);</div><h2>üéØ Custom Sections</h2><div class="code-box">/* Create custom section in linker script */<br>.ccmram : {<br>    . = ALIGN(4);<br>    _sccmram = .;<br>    *(.ccmram)<br>    *(.ccmram*)<br>    . = ALIGN(4);<br>    _eccmram = .;<br>} > CCMRAM<br><br>/* In C code: */<br>__attribute__((section(".ccmram")))<br>uint32_t fast_buffer[256];<br><br>/* Place function in RAM for speed */<br>__attribute__((section(".ramfunc")))<br>void critical_function(void) {<br>    // Runs from RAM (faster than Flash)<br>}</div><h2>üó∫Ô∏è Multiple Memory Regions</h2><div class="code-box">MEMORY {<br>    FLASH (rx)   : ORIGIN = 0x08000000, LENGTH = 512K<br>    RAM (rwx)    : ORIGIN = 0x20000000, LENGTH = 128K<br>    CCMRAM (rw)  : ORIGIN = 0x10000000, LENGTH = 64K<br>    BACKUP (rw)  : ORIGIN = 0x40024000, LENGTH = 4K<br>}<br><br>SECTIONS {<br>    /* Code in Flash */<br>    .text : { *(.text*) } > FLASH<br>    <br>    /* Fast data in CCM RAM */<br>    .ccmram : { *(.ccmram*) } > CCMRAM<br>    <br>    /* Persistent data in backup RAM */<br>    .backup : { *(.backup*) } > BACKUP<br>}</div><h2>üìä Stack and Heap Placement</h2><div class="code-box">/* Define stack and heap sizes */<br>_Min_Heap_Size = 0x200;   /* 512 bytes */<br>_Min_Stack_Size = 0x400;  /* 1024 bytes */<br><br>/* Stack grows downward from end of RAM */<br>_estack = ORIGIN(RAM) + LENGTH(RAM);<br><br>/* Heap and stack section */<br>._user_heap_stack : {<br>    . = ALIGN(8);<br>    PROVIDE(end = .);<br>    PROVIDE(_end = .);<br>    . = . + _Min_Heap_Size;   /* Reserve heap */<br>    . = . + _Min_Stack_Size;  /* Reserve stack */<br>    . = ALIGN(8);<br>} > RAM<br><br>/* Check for overflow */<br>ASSERT(. <= _estack, "Error: RAM overflow!")</div><h2>‚ö†Ô∏è ASSERT for Safety</h2><div class="code-box">/* Runtime checks in linker script */<br><br>/* Check Flash doesn't overflow */<br>ASSERT(SIZEOF(.text) + SIZEOF(.data) < LENGTH(FLASH),<br>       "Error: Flash overflow!")<br><br>/* Check RAM doesn't overflow */<br>ASSERT(SIZEOF(.data) + SIZEOF(.bss) + _Min_Heap_Size + _Min_Stack_Size < LENGTH(RAM),<br>       "Error: RAM overflow!")<br><br>/* Check alignment */<br>ASSERT((ADDR(.isr_vector) & 0x1FF) == 0,<br>       "Error: Vector table must be 512-byte aligned!")</div><h2>üîÑ OVERLAY for Code Swapping</h2><div class="code-box">/* Overlay sections (share same RAM) */<br>OVERLAY : {<br>    .overlay1 { *(.overlay1) }<br>    .overlay2 { *(.overlay2) }<br>} > RAM<br><br>/* Both sections use same RAM address<br>   Load one at a time as needed<br>   Useful for large applications with limited RAM<br>*/</div><h2>üìã INCLUDE Directive</h2><div class="code-box">/* Main linker script */<br>INCLUDE memory_map.ld<br>INCLUDE sections.ld<br><br>/* memory_map.ld */<br>MEMORY {<br>    FLASH : ORIGIN = 0x08000000, LENGTH = 512K<br>    RAM   : ORIGIN = 0x20000000, LENGTH = 128K<br>}<br><br>/* sections.ld */<br>SECTIONS {<br>    .text : { *(.text*) } > FLASH<br>    .data : { *(.data*) } > RAM AT> FLASH<br>}</div><h2>üéØ Complete Advanced Example</h2><div class="code-box">/* Advanced STM32F4 Linker Script */<br><br>ENTRY(Reset_Handler)<br><br>_estack = ORIGIN(RAM) + LENGTH(RAM);<br>_Min_Heap_Size = 0x200;<br>_Min_Stack_Size = 0x400;<br><br>MEMORY {<br>    FLASH (rx)   : ORIGIN = 0x08000000, LENGTH = 1024K<br>    RAM (xrw)    : ORIGIN = 0x20000000, LENGTH = 128K<br>    CCMRAM (rw)  : ORIGIN = 0x10000000, LENGTH = 64K<br>}<br><br>SECTIONS {<br>    /* Vector table (must be 512-byte aligned) */<br>    .isr_vector : {<br>        . = ALIGN(512);<br>        KEEP(*(.isr_vector))<br>    } > FLASH<br>    <br>    /* Code */<br>    .text : {<br>        . = ALIGN(4);<br>        *(.text)<br>        *(.text*)<br>        *(.rodata)<br>        *(.rodata*)<br>        . = ALIGN(4);<br>        _etext = .;<br>    } > FLASH<br>    <br>    /* RAM functions (code in RAM) */<br>    .ramfunc : {<br>        . = ALIGN(4);<br>        _sramfunc = .;<br>        *(.ramfunc)<br>        . = ALIGN(4);<br>        _eramfunc = .;<br>    } > RAM AT> FLASH<br>    <br>    _siramfunc = LOADADDR(.ramfunc);<br>    <br>    /* Initialized data */<br>    .data : {<br>        . = ALIGN(4);<br>        _sdata = .;<br>        *(.data)<br>        *(.data*)<br>        . = ALIGN(4);<br>        _edata = .;<br>    } > RAM AT> FLASH<br>    <br>    _sidata = LOADADDR(.data);<br>    <br>    /* Uninitialized data */<br>    .bss : {<br>        . = ALIGN(4);<br>        _sbss = .;<br>        *(.bss)<br>        *(.bss*)<br>        *(COMMON)<br>        . = ALIGN(4);<br>        _ebss = .;<br>    } > RAM<br>    <br>    /* CCM RAM section */<br>    .ccmram : {<br>        . = ALIGN(4);<br>        _sccmram = .;<br>        *(.ccmram)<br>        *(.ccmram*)<br>        . = ALIGN(4);<br>        _eccmram = .;<br>    } > CCMRAM<br>    <br>    /* Heap and stack */<br>    ._user_heap_stack : {<br>        . = ALIGN(8);<br>        PROVIDE(end = .);<br>        . = . + _Min_Heap_Size;<br>        . = . + _Min_Stack_Size;<br>        . = ALIGN(8);<br>    } > RAM<br>    <br>    /* Safety checks */<br>    ASSERT(. <= _estack, "RAM overflow!")<br>}<br><br>/* Provide weak symbols */<br>PROVIDE(__stack = _estack);<br>PROVIDE(_heap_start = end);</div><div class="fun-fact"><strong>üåü Linker Power:</strong><p style="margin-top:10px;margin-bottom:0">The linker script is one of the most powerful tools in embedded development. You can place specific functions in RAM for speed, use multiple memory regions, create custom sections, and even detect memory overflows at compile time. Master this, and you control everything!</p></div><div class="quiz-box"><h3>üß† Test Your Knowledge!</h3><p><strong>Question:</strong> What does the KEEP directive prevent?</p><ul><li>A) Memory overflow</li><li>B) Garbage collection of sections ‚úì</li><li>C) Alignment issues</li><li>D) Stack corruption</li></ul><p style="margin-top:15px"><em>Answer: B - KEEP prevents the linker from removing "unused" sections!</em></p></div></div>`,
    questions: [{ q: "What does the KEEP directive prevent?", options: ["Memory overflow", "Garbage collection of sections", "Alignment issues", "Stack corruption"], answer: 1 }],
    tools: [{ name: "Advanced Linker Tool", type: "interactive", description: "Create complex linker scripts" }]
};
