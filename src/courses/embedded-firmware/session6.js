export const session6 = {
    title: "GCC Compiler Deep Dive",
    content: `<style>.firmware-lesson{padding:0;margin:0}.firmware-lesson h2{color:#e74c3c;margin-top:40px;margin-bottom:20px;font-size:1.8em;border-left:5px solid #e74c3c;padding-left:15px}.hero-box{background:linear-gradient(135deg,rgba(231,76,60,0.1) 0%,rgba(192,57,43,0.1) 100%);border-radius:15px;padding:30px;margin:30px 0;text-align:center;border:2px solid rgba(231,76,60,0.2)}.info-box{background:#f8f9fa;border-left:5px solid #e74c3c;padding:20px;margin:25px 0;border-radius:8px}.cards-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:20px;margin:25px 0}.info-card{background:linear-gradient(135deg,rgba(231,76,60,0.08) 0%,rgba(192,57,43,0.08) 100%);padding:25px;border-radius:12px;border:2px solid rgba(231,76,60,0.2);transition:all 0.3s ease}.info-card:hover{transform:translateY(-5px);box-shadow:0 10px 25px rgba(231,76,60,0.2)}.card-icon{font-size:50px;margin-bottom:15px;display:block}.info-card h4{color:#e74c3c;margin-bottom:10px;font-size:1.2em}.firmware-lesson p{color:#333;margin-bottom:15px;font-size:1.05em;line-height:1.7}.firmware-lesson ul{margin:15px 0 15px 25px}.code-box{background:#1e1e1e;color:#d4d4d4;padding:20px;border-radius:10px;margin:20px 0;font-family:monospace;overflow-x:auto;font-size:14px}.quiz-box{background:#fff9e6;padding:25px;border-radius:15px;margin-top:30px;border:3px solid #ffd700}.fun-fact{background:#e8f5e9;border-left:5px solid #4caf50;padding:20px;margin:25px 0;border-radius:8px}</style><div class="firmware-lesson"><div class="hero-box"><div style="font-size:60px;margin-bottom:15px">‚öôÔ∏è</div><p>GCC Compiler: Transforming C code into ARM machine code!</p></div><h2>üîÑ Compilation Stages</h2><div class="code-box">Source Code ‚Üí Executable (4 stages):<br><br>1. Preprocessing (.c ‚Üí .i)<br>   - Remove comments<br>   - Expand #include, #define<br>   - Process #if, #ifdef<br><br>2. Compilation (.i ‚Üí .s)<br>   - Parse C code<br>   - Generate assembly code<br>   - Optimize<br><br>3. Assembly (.s ‚Üí .o)<br>   - Convert assembly to machine code<br>   - Create object file<br><br>4. Linking (.o ‚Üí .elf)<br>   - Combine object files<br>   - Resolve symbols<br>   - Apply linker script</div><div class="code-box"># See each stage manually<br><br># 1. Preprocessing only<br>arm-none-eabi-gcc -E main.c -o main.i<br><br># 2. Compile to assembly<br>arm-none-eabi-gcc -S main.c -o main.s<br><br># 3. Assemble to object<br>arm-none-eabi-gcc -c main.c -o main.o<br><br># 4. Link to executable<br>arm-none-eabi-gcc main.o -o firmware.elf</div><h2>üéØ Essential GCC Flags for Embedded</h2><div class="info-box"><strong>Architecture Flags (REQUIRED):</strong></div><div class="code-box"># CPU and instruction set<br>-mcpu=cortex-m4        # Target Cortex-M4<br>-mthumb                # Use Thumb instruction set (16/32-bit)<br>-mfloat-abi=hard       # Hardware floating point<br>-mfpu=fpv4-sp-d16      # FPU type<br><br># Example for STM32F4<br>CFLAGS = -mcpu=cortex-m4 -mthumb -mfloat-abi=hard -mfpu=fpv4-sp-d16</div><h2>‚ö° Optimization Levels</h2><div class="cards-grid"><div class="info-card"><span class="card-icon">-O0</span><h4>No Optimization</h4><p>Fast compile, easy debug, large/slow code</p></div><div class="info-card"><span class="card-icon">-O1</span><h4>Basic</h4><p>Moderate optimization, reasonable size</p></div><div class="info-card"><span class="card-icon">-O2</span><h4>Recommended</h4><p>Good balance, most common for production</p></div><div class="info-card"><span class="card-icon">-O3</span><h4>Aggressive</h4><p>Maximum speed, larger code</p></div><div class="info-card"><span class="card-icon">-Os</span><h4>Size</h4><p>Optimize for size, best for small Flash</p></div><div class="info-card"><span class="card-icon">-Og</span><h4>Debug</h4><p>Optimize but keep debuggable</p></div></div><div class="code-box"># Optimization comparison<br><br>int sum(int a, int b) {<br>    int result = a + b;<br>    return result;<br>}<br><br># -O0 (No optimization):<br>  push {r7}<br>  add r7, sp, #0<br>  str r0, [r7, #4]<br>  str r1, [r7, #0]<br>  ldr r2, [r7, #4]<br>  ldr r3, [r7, #0]<br>  add r3, r3, r2<br>  str r3, [r7, #8]<br>  ldr r3, [r7, #8]<br>  mov r0, r3<br>  pop {r7}<br>  bx lr<br><br># -O2 (Optimized):<br>  add r0, r0, r1<br>  bx lr</div><h2>‚ö†Ô∏è Warning Flags</h2><div class="code-box"># Essential warnings<br>-Wall                  # Enable most warnings<br>-Wextra                # Extra warnings<br>-Werror                # Treat warnings as errors<br>-Wno-unused-parameter  # Ignore unused params<br><br># Recommended for embedded<br>CFLAGS += -Wall -Wextra -Werror</div><h2>üîç Debugging Flags</h2><div class="code-box"># Debug information<br>-g                     # Include debug symbols<br>-g3                    # Maximum debug info (includes macros)<br>-gdwarf-2              # DWARF-2 debug format<br><br># For debugging<br>CFLAGS += -g3 -gdwarf-2</div><h2>üì¶ Include and Define Flags</h2><div class="code-box"># Include directories<br>-I./inc                # Add include path<br>-I./drivers/inc<br><br># Preprocessor defines<br>-DSTM32F407xx          # Define MCU model<br>-DUSE_HAL_DRIVER       # Enable HAL<br>-DDEBUG                # Debug mode<br><br># Example<br>CFLAGS += -I./inc -I./drivers -DSTM32F407xx</div><h2>üîó Linker Flags</h2><div class="code-box"># Linker script<br>-T linker/STM32F407.ld # Specify linker script<br><br># Map file (shows memory layout)<br>-Wl,-Map=output.map    # Generate map file<br><br># Garbage collection (remove unused code)<br>-Wl,--gc-sections      # Remove unused sections<br>-ffunction-sections    # Each function in own section<br>-fdata-sections        # Each data in own section<br><br># Complete linker flags<br>LDFLAGS = -T linker/STM32F407.ld -Wl,-Map=firmware.map -Wl,--gc-sections</div><h2>üéØ Complete GCC Command Example</h2><div class="code-box"># Compile single file<br>arm-none-eabi-gcc \<br>  -mcpu=cortex-m4 \<br>  -mthumb \<br>  -mfloat-abi=hard \<br>  -mfpu=fpv4-sp-d16 \<br>  -O2 \<br>  -Wall -Wextra \<br>  -g3 \<br>  -I./inc \<br>  -DSTM32F407xx \<br>  -ffunction-sections \<br>  -fdata-sections \<br>  -c main.c -o main.o<br><br># Link<br>arm-none-eabi-gcc \<br>  -mcpu=cortex-m4 \<br>  -mthumb \<>  -T linker/STM32F407.ld \<br>  -Wl,-Map=firmware.map \<br>  -Wl,--gc-sections \<br>  main.o startup.o \<br>  -o firmware.elf</div><h2>üìä Analyzing Compilation</h2><div class="code-box"># Verbose output<br>arm-none-eabi-gcc -v main.c<br><br># Preprocessor output<br>arm-none-eabi-gcc -E main.c | less<br><br># Assembly output with source<br>arm-none-eabi-gcc -S -fverbose-asm main.c<br><br># Show included files<br>arm-none-eabi-gcc -M main.c</div><h2>‚öôÔ∏è Cross-Compilation Specifics</h2><div class="info-box"><strong>Why "arm-none-eabi"?</strong><ul><li><strong>arm:</strong> ARM architecture</li><li><strong>none:</strong> No operating system (bare-metal)</li><li><strong>eabi:</strong> Embedded Application Binary Interface</li></ul></div><div class="code-box"># Compiler triplet: arch-vendor-os-abi<br><br>arm-none-eabi-gcc     # ARM, no OS, EABI<br>arm-linux-gnueabi-gcc # ARM, Linux, EABI<br>x86_64-linux-gnu-gcc  # x86-64, Linux, GNU</div><div class="fun-fact"><strong>üåü GCC Power:</strong><p style="margin-top:10px;margin-bottom:0">GCC can optimize your code in over 200 different ways! The -O2 flag enables around 70 optimizations. Some optimizations can make your code 10x faster while using 50% less memory. That's why choosing the right flags matters!</p></div><div class="quiz-box"><h3>üß† Test Your Knowledge!</h3><p><strong>Question:</strong> Which optimization flag is best for limited Flash memory?</p><ul><li>A) -O0</li><li>B) -O3</li><li>C) -Os ‚úì</li><li>D) -Og</li></ul><p style="margin-top:15px"><em>Answer: C - -Os optimizes for size, perfect for small Flash!</em></p></div></div>`,
    questions: [{ q: "Which optimization flag is best for limited Flash memory?", options: ["-O0", "-O3", "-Os", "-Og"], answer: 2 }],
    tools: [{ name: "GCC Flag Explorer", type: "interactive", description: "Explore compiler flags" }]
};
