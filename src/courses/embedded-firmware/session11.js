export const session11 = {
    title: "Vector Table and Interrupt Vectors",
    content: `<style>.firmware-lesson{padding:0;margin:0}.firmware-lesson h2{color:#e74c3c;margin-top:40px;margin-bottom:20px;font-size:1.8em;border-left:5px solid #e74c3c;padding-left:15px}.hero-box{background:linear-gradient(135deg,rgba(231,76,60,0.1) 0%,rgba(192,57,43,0.1) 100%);border-radius:15px;padding:30px;margin:30px 0;text-align:center;border:2px solid rgba(231,76,60,0.2)}.info-box{background:#f8f9fa;border-left:5px solid #e74c3c;padding:20px;margin:25px 0;border-radius:8px}.cards-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:20px;margin:25px 0}.info-card{background:linear-gradient(135deg,rgba(231,76,60,0.08) 0%,rgba(192,57,43,0.08) 100%);padding:25px;border-radius:12px;border:2px solid rgba(231,76,60,0.2);transition:all 0.3s ease}.info-card:hover{transform:translateY(-5px);box-shadow:0 10px 25px rgba(231,76,60,0.2)}.card-icon{font-size:50px;margin-bottom:15px;display:block}.info-card h4{color:#e74c3c;margin-bottom:10px;font-size:1.2em}.firmware-lesson p{color:#333;margin-bottom:15px;font-size:1.05em;line-height:1.7}.firmware-lesson ul{margin:15px 0 15px 25px}.code-box{background:#1e1e1e;color:#d4d4d4;padding:20px;border-radius:10px;margin:20px 0;font-family:monospace;overflow-x:auto;font-size:14px}.quiz-box{background:#fff9e6;padding:25px;border-radius:15px;margin-top:30px;border:3px solid #ffd700}.fun-fact{background:#e8f5e9;border-left:5px solid #4caf50;padding:20px;margin:25px 0;border-radius:8px}</style><div class="firmware-lesson"><div class="hero-box"><div style="font-size:60px;margin-bottom:15px">üìã</div><p>Vector Table: The roadmap for handling exceptions and interrupts!</p></div><h2>üéØ What is the Vector Table?</h2><p>The <strong>vector table</strong> is an array of function pointers at the start of Flash memory. When an exception or interrupt occurs, the processor looks up the handler address in this table.</p><div class="info-box"><strong>Vector Table Location:</strong><ul><li>MUST be at 0x08000000 (Flash start) or 0x00000000 (aliased)</li><li>MUST be aligned to 512 bytes (for Cortex-M4)</li><li>First entry is initial stack pointer</li><li>Second entry is Reset_Handler address</li></ul></div><h2>üìä Vector Table Structure</h2><div class="code-box">/* Vector table layout (STM32F4) */<br><br>Offset  Exception Number  Handler<br>0x0000  -                 Initial SP value<br>0x0004  1                 Reset_Handler<br>0x0008  2                 NMI_Handler<br>0x000C  3                 HardFault_Handler<br>0x0010  4                 MemManage_Handler<br>0x0014  5                 BusFault_Handler<br>0x0018  6                 UsageFault_Handler<br>0x001C  7-10              Reserved<br>0x002C  11                SVC_Handler<br>0x0030  12                DebugMon_Handler<br>0x0034  13                Reserved<br>0x0038  14                PendSV_Handler<br>0x003C  15                SysTick_Handler<br>0x0040  16+               External IRQs...</div><h2>üíª Defining Vector Table in C</h2><div class="code-box">/* startup.c - Vector table definition */<br><br>extern uint32_t _estack;  /* From linker script */<br><br>/* Function prototypes */<br>void Reset_Handler(void);<br>void NMI_Handler(void);<br>void HardFault_Handler(void);<br>void MemManage_Handler(void);<br>void BusFault_Handler(void);<br>void UsageFault_Handler(void);<br>void SVC_Handler(void);<br>void DebugMon_Handler(void);<br>void PendSV_Handler(void);<br>void SysTick_Handler(void);<br><br>/* External interrupt handlers */<br>void WWDG_IRQHandler(void);<br>void EXTI0_IRQHandler(void);<br>void USART1_IRQHandler(void);<br>/* ... more handlers ... */<br><br>/* Vector table */<br>__attribute__((section(".isr_vector")))<br>void (* const g_pfnVectors[])(void) = {<br>    (void (*)(void))((uint32_t)&_estack),  /* Initial SP */<br>    Reset_Handler,              /* Reset */<br>    NMI_Handler,                /* NMI */<br>    HardFault_Handler,          /* Hard Fault */<br>    MemManage_Handler,          /* MPU Fault */<br>    BusFault_Handler,           /* Bus Fault */<br>    UsageFault_Handler,         /* Usage Fault */<br>    0,                          /* Reserved */<br>    0,                          /* Reserved */<br>    0,                          /* Reserved */<br>    0,                          /* Reserved */<br>    SVC_Handler,                /* SVCall */<br>    DebugMon_Handler,           /* Debug Monitor */<br>    0,                          /* Reserved */<br>    PendSV_Handler,             /* PendSV */<br>    SysTick_Handler,            /* SysTick */<br>    <br>    /* External Interrupts */<br>    WWDG_IRQHandler,            /* Window Watchdog */<br>    EXTI0_IRQHandler,           /* EXTI Line 0 */<br>    /* ... 80+ more interrupts ... */<br>};</div><h2>üîß Weak Symbols for Default Handlers</h2><div class="code-box">/* Default handler (infinite loop) */<br>void Default_Handler(void) {<br>    while(1);<br>}<br><br>/* Weak aliases - can be overridden */<br>void NMI_Handler(void) __attribute__((weak, alias("Default_Handler")));<br>void HardFault_Handler(void) __attribute__((weak, alias("Default_Handler")));<br>void MemManage_Handler(void) __attribute__((weak, alias("Default_Handler")));<br>void BusFault_Handler(void) __attribute__((weak, alias("Default_Handler")));<br>void UsageFault_Handler(void) __attribute__((weak, alias("Default_Handler")));<br>void SVC_Handler(void) __attribute__((weak, alias("Default_Handler")));<br>void DebugMon_Handler(void) __attribute__((weak, alias("Default_Handler")));<br>void PendSV_Handler(void) __attribute__((weak, alias("Default_Handler")));<br>void SysTick_Handler(void) __attribute__((weak, alias("Default_Handler")));<br><br>/* External interrupts */<br>void WWDG_IRQHandler(void) __attribute__((weak, alias("Default_Handler")));<br>void EXTI0_IRQHandler(void) __attribute__((weak, alias("Default_Handler")));<br>void USART1_IRQHandler(void) __attribute__((weak, alias("Default_Handler")));</div><h2>üéØ Implementing Custom Handlers</h2><div class="code-box">/* In your application code (main.c) */<br><br>/* Override weak handler */<br>void USART1_IRQHandler(void) {<br>    /* Check if RXNE (receive not empty) */<br>    if (USART1->SR & USART_SR_RXNE) {<br>        uint8_t data = USART1->DR;<br>        /* Process received data */<br>    }<br>    <br>    /* Clear interrupt flags if needed */<br>}<br><br>/* SysTick handler for timing */<br>volatile uint32_t tick_count = 0;<br><br>void SysTick_Handler(void) {<br>    tick_count++;<br>}</div><h2>‚ö†Ô∏è Fault Handlers</h2><div class="code-box">/* HardFault handler with debug info */<br>void HardFault_Handler(void) {<br>    /* Get fault status registers */<br>    volatile uint32_t *cfsr = (uint32_t*)0xE000ED28;<br>    volatile uint32_t *hfsr = (uint32_t*)0xE000ED2C;<br>    volatile uint32_t *mmfar = (uint32_t*)0xE000ED34;<br>    volatile uint32_t *bfar = (uint32_t*)0xE000ED38;<br>    <br>    /* Read fault info */<br>    uint32_t cfsr_val = *cfsr;<br>    uint32_t hfsr_val = *hfsr;<br>    uint32_t mmfar_val = *mmfar;<br>    uint32_t bfar_val = *bfar;<br>    <br>    /* Infinite loop for debugging */<br>    while(1) {<br>        /* Set breakpoint here */<br>        __asm("NOP");<br>    }<br>}</div><h2>üìã Complete Vector Table Example</h2><div class="code-box">/* startup_stm32f407.c */<br><br>#include <stdint.h><br><br>extern uint32_t _estack;<br>extern uint32_t _sidata, _sdata, _edata;<br>extern uint32_t _sbss, _ebss;<br><br>void Reset_Handler(void);<br>void Default_Handler(void);<br><br>/* System exceptions */<br>void NMI_Handler(void) __attribute__((weak, alias("Default_Handler")));<br>void HardFault_Handler(void) __attribute__((weak, alias("Default_Handler")));<br>void MemManage_Handler(void) __attribute__((weak, alias("Default_Handler")));<br>void BusFault_Handler(void) __attribute__((weak, alias("Default_Handler")));<br>void UsageFault_Handler(void) __attribute__((weak, alias("Default_Handler")));<br>void SVC_Handler(void) __attribute__((weak, alias("Default_Handler")));<br>void DebugMon_Handler(void) __attribute__((weak, alias("Default_Handler")));<br>void PendSV_Handler(void) __attribute__((weak, alias("Default_Handler")));<br>void SysTick_Handler(void) __attribute__((weak, alias("Default_Handler")));<br><br>/* External interrupts (STM32F407 has 82) */<br>void WWDG_IRQHandler(void) __attribute__((weak, alias("Default_Handler")));<br>void PVD_IRQHandler(void) __attribute__((weak, alias("Default_Handler")));<br>void TAMP_STAMP_IRQHandler(void) __attribute__((weak, alias("Default_Handler")));<br>/* ... 79 more ... */<br><br>/* Vector table */<br>__attribute__((section(".isr_vector")))<br>void (* const g_pfnVectors[])(void) = {<br>    (void (*)(void))((uint32_t)&_estack),<br>    Reset_Handler,<br>    NMI_Handler,<br>    HardFault_Handler,<br>    MemManage_Handler,<br>    BusFault_Handler,<br>    UsageFault_Handler,<br>    0, 0, 0, 0,<br>    SVC_Handler,<br>    DebugMon_Handler,<br>    0,<br>    PendSV_Handler,<br>    SysTick_Handler,<br>    WWDG_IRQHandler,<br>    PVD_IRQHandler,<br>    TAMP_STAMP_IRQHandler,<br>    /* ... 79 more ... */<br>};<br><br>/* Default handler */<br>void Default_Handler(void) {<br>    while(1);<br>}</div><h2>üîç Verifying Vector Table</h2><div class="code-box"># View vector table in ELF file<br>arm-none-eabi-objdump -s -j .isr_vector firmware.elf<br><br># Output:<br>Contents of section .isr_vector:<br> 8000000 00000220 89010008 91010008 93010008  ... ............<br> 8000010 95010008 97010008 99010008 00000000  ................<br><br># First 4 bytes: 0x20000000 (initial SP)<br># Next 4 bytes: 0x08000189 (Reset_Handler address)</div><div class="fun-fact"><strong>üåü Vector Table Magic:</strong><p style="margin-top:10px;margin-bottom:0">The ARM Cortex-M processor automatically saves 8 registers (R0-R3, R12, LR, PC, xPSR) to the stack when entering an interrupt, and restores them when exiting. This is called "hardware stacking" and it's AUTOMATIC - you don't write any assembly code for it!</p></div><div class="quiz-box"><h3>üß† Test Your Knowledge!</h3><p><strong>Question:</strong> What is stored at offset 0x0000 in the vector table?</p><ul><li>A) Reset_Handler address</li><li>B) Initial stack pointer value ‚úì</li><li>C) Flash start address</li><li>D) RAM start address</li></ul><p style="margin-top:15px"><em>Answer: B - The first entry is the initial stack pointer value!</em></p></div></div>`,
    questions: [{ q: "What is stored at offset 0x0000 in the vector table?", options: ["Reset_Handler address", "Initial stack pointer value", "Flash start address", "RAM start address"], answer: 1 }],
    tools: [{ name: "Vector Table Generator", type: "interactive", description: "Generate vector tables for different MCUs" }]
};
