export const session7 = {
    title: "Makefiles for Embedded Systems",
    content: `<style>.firmware-lesson{padding:0;margin:0}.firmware-lesson h2{color:#e74c3c;margin-top:40px;margin-bottom:20px;font-size:1.8em;border-left:5px solid #e74c3c;padding-left:15px}.hero-box{background:linear-gradient(135deg,rgba(231,76,60,0.1) 0%,rgba(192,57,43,0.1) 100%);border-radius:15px;padding:30px;margin:30px 0;text-align:center;border:2px solid rgba(231,76,60,0.2)}.info-box{background:#f8f9fa;border-left:5px solid #e74c3c;padding:20px;margin:25px 0;border-radius:8px}.cards-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:20px;margin:25px 0}.info-card{background:linear-gradient(135deg,rgba(231,76,60,0.08) 0%,rgba(192,57,43,0.08) 100%);padding:25px;border-radius:12px;border:2px solid rgba(231,76,60,0.2);transition:all 0.3s ease}.info-card:hover{transform:translateY(-5px);box-shadow:0 10px 25px rgba(231,76,60,0.2)}.card-icon{font-size:50px;margin-bottom:15px;display:block}.info-card h4{color:#e74c3c;margin-bottom:10px;font-size:1.2em}.firmware-lesson p{color:#333;margin-bottom:15px;font-size:1.05em;line-height:1.7}.firmware-lesson ul{margin:15px 0 15px 25px}.code-box{background:#1e1e1e;color:#d4d4d4;padding:20px;border-radius:10px;margin:20px 0;font-family:monospace;overflow-x:auto;font-size:14px}.quiz-box{background:#fff9e6;padding:25px;border-radius:15px;margin-top:30px;border:3px solid #ffd700}.fun-fact{background:#e8f5e9;border-left:5px solid #4caf50;padding:20px;margin:25px 0;border-radius:8px}</style><div class="firmware-lesson"><div class="hero-box"><div style="font-size:60px;margin-bottom:15px">üî®</div><p>Makefiles: Automate your embedded build process!</p></div><h2>üìã What is Make?</h2><p>Make is a build automation tool that reads a <strong>Makefile</strong> to compile your project. It only recompiles files that have changed, saving time!</p><div class="code-box"># Basic Makefile structure<br><br>target: dependencies<br>	command<br><br># Example:<br>main.o: main.c<br>	arm-none-eabi-gcc -c main.c -o main.o</div><h2>üéØ Complete Embedded Makefile</h2><div class="code-box"># Makefile for STM32F4<br><br>########## Project Settings ##########<br>PROJECT = firmware<br>MCU = STM32F407xx<br><br>########## Toolchain ##########<br>CC = arm-none-eabi-gcc<br>OBJCOPY = arm-none-eabi-objcopy<br>SIZE = arm-none-eabi-size<br><br>########## Source Files ##########<br>SRC_DIR = src<br>INC_DIR = inc<br>BUILD_DIR = build<br><br>SOURCES = $(wildcard $(SRC_DIR)/*.c)<br>OBJECTS = $(SOURCES:$(SRC_DIR)/%.c=$(BUILD_DIR)/%.o)<br><br>########## Compiler Flags ##########<br>CFLAGS = -mcpu=cortex-m4<br>CFLAGS += -mthumb<br>CFLAGS += -mfloat-abi=hard<br>CFLAGS += -mfpu=fpv4-sp-d16<br>CFLAGS += -O2<br>CFLAGS += -Wall -Wextra<br>CFLAGS += -g3<br>CFLAGS += -I$(INC_DIR)<br>CFLAGS += -D$(MCU)<br>CFLAGS += -ffunction-sections<br>CFLAGS += -fdata-sections<br><br>########## Linker Flags ##########<br>LDFLAGS = -T linker/STM32F407.ld<br>LDFLAGS += -Wl,-Map=$(BUILD_DIR)/$(PROJECT).map<br>LDFLAGS += -Wl,--gc-sections<br>LDFLAGS += --specs=nano.specs<br><br>########## Build Rules ##########<br>all: $(BUILD_DIR)/$(PROJECT).bin<br><br>$(BUILD_DIR)/%.o: $(SRC_DIR)/%.c | $(BUILD_DIR)<br>	$(CC) $(CFLAGS) -c $< -o $@<br><br>$(BUILD_DIR)/$(PROJECT).elf: $(OBJECTS)<br>	$(CC) $(CFLAGS) $(LDFLAGS) $^ -o $@<br>	$(SIZE) $@<br><br>$(BUILD_DIR)/$(PROJECT).bin: $(BUILD_DIR)/$(PROJECT).elf<br>	$(OBJCOPY) -O binary $< $@<br><br>$(BUILD_DIR):<br>	mkdir -p $@<br><br>clean:<br>	rm -rf $(BUILD_DIR)<br><br>flash: $(BUILD_DIR)/$(PROJECT).bin<br>	openocd -f openocd.cfg -c "program $< 0x08000000 verify reset exit"<br><br>.PHONY: all clean flash</div><h2>üî§ Makefile Variables</h2><div class="code-box"># Variable assignment<br>CC = arm-none-eabi-gcc    # Simple assignment<br>CC := arm-none-eabi-gcc   # Immediate assignment<br>CC ?= arm-none-eabi-gcc   # Conditional (if not set)<br>CC += -Wall               # Append<br><br># Using variables<br>$(CC)                     # Reference variable<br><br># Automatic variables<br>$@    # Target name<br>$<    # First dependency<br>$^    # All dependencies<br>$?    # Dependencies newer than target<br>$*    # Stem of pattern rule</div><h2>üìÅ Pattern Rules</h2><div class="code-box"># Pattern rule for .c ‚Üí .o<br>%.o: %.c<br>	$(CC) $(CFLAGS) -c $< -o $@<br><br># With build directory<br>$(BUILD_DIR)/%.o: $(SRC_DIR)/%.c<br>	$(CC) $(CFLAGS) -c $< -o $@<br><br># Multiple patterns<br>%.hex: %.elf<br>	$(OBJCOPY) -O ihex $< $@<br><br>%.bin: %.elf<br>	$(OBJCOPY) -O binary $< $@</div><h2>üéØ Wildcard and Functions</h2><div class="code-box"># Wildcard - find files<br>SOURCES = $(wildcard src/*.c)<br># Result: src/main.c src/gpio.c src/uart.c<br><br># Substitution - change extension<br>OBJECTS = $(SOURCES:.c=.o)<br># Result: src/main.o src/gpio.o src/uart.o<br><br># Pattern substitution<br>OBJECTS = $(SOURCES:src/%.c=build/%.o)<br># Result: build/main.o build/gpio.o build/uart.o<br><br># Patsubst function<br>OBJECTS = $(patsubst src/%.c,build/%.o,$(SOURCES))</div><h2>üîó Dependencies</h2><div class="code-box"># Manual dependencies<br>main.o: main.c main.h gpio.h<br>	$(CC) $(CFLAGS) -c main.c<br><br># Auto-generate dependencies<br>DEPS = $(OBJECTS:.o=.d)<br><br>-include $(DEPS)<br><br># Generate .d files<br>$(BUILD_DIR)/%.o: $(SRC_DIR)/%.c<br>	$(CC) $(CFLAGS) -MMD -MP -c $< -o $@</div><h2>‚öôÔ∏è Phony Targets</h2><div class="code-box"># Phony targets (not real files)<br>.PHONY: all clean flash debug<br><br>all: firmware.bin<br><br>clean:<br>	rm -rf build/<br><br>flash: firmware.bin<br>	openocd -f openocd.cfg -c "program $< verify reset exit"<br><br>debug: firmware.elf<br>	openocd -f openocd.cfg &<br>	arm-none-eabi-gdb $<<br><br>size: firmware.elf<br>	arm-none-eabi-size -A $<</div><h2>üìä Advanced Makefile Features</h2><div class="code-box"># Conditional compilation<br>DEBUG ?= 1<br>ifeq ($(DEBUG), 1)<br>    CFLAGS += -DDEBUG -O0 -g3<br>else<br>    CFLAGS += -O2<br>endif<br><br># Multiple targets<br>MCU ?= STM32F407<br>ifeq ($(MCU), STM32F407)<br>    LDSCRIPT = linker/STM32F407.ld<br>else ifeq ($(MCU), STM32F103)<br>    LDSCRIPT = linker/STM32F103.ld<br>endif<br><br># Silent mode<br>.SILENT:<br><br># Or per-command<br>@$(CC) $(CFLAGS) -c $< -o $@</div><h2>üé® Pretty Output</h2><div class="code-box"># Colored output<br>RED = \\033[0;31m<br>GREEN = \\033[0;32m<br>YELLOW = \\033[0;33m<br>NC = \\033[0m  # No Color<br><br>$(BUILD_DIR)/%.o: $(SRC_DIR)/%.c<br>	@echo "$(YELLOW)[CC]$(NC) $<"<br>	@$(CC) $(CFLAGS) -c $< -o $@<br><br>$(PROJECT).elf: $(OBJECTS)<br>	@echo "$(GREEN)[LD]$(NC) $@"<br>	@$(CC) $(CFLAGS) $(LDFLAGS) $^ -o $@</div><h2>üöÄ Running Make</h2><div class="code-box"># Build everything<br>make<br>make all<br><br># Clean build directory<br>make clean<br><br># Flash firmware<br>make flash<br><br># Rebuild from scratch<br>make clean all<br><br># Build with specific target<br>make MCU=STM32F103<br><br># Parallel build (faster)<br>make -j4<br><br># Verbose mode<br>make V=1</div><div class="fun-fact"><strong>üåü Make History:</strong><p style="margin-top:10px;margin-bottom:0">Make was created in 1976 by Stuart Feldman at Bell Labs - almost 50 years ago! Despite its age, it's still the most popular build tool for embedded systems. Modern alternatives exist (CMake, Ninja), but Make's simplicity keeps it relevant!</p></div><div class="quiz-box"><h3>üß† Test Your Knowledge!</h3><p><strong>Question:</strong> What does the automatic variable $@ represent?</p><ul><li>A) First dependency</li><li>B) All dependencies</li><li>C) Target name ‚úì</li><li>D) Source file</li></ul><p style="margin-top:15px"><em>Answer: C - $@ is the target name in a Makefile rule!</em></p></div></div>`,
    questions: [{ q: "What does the automatic variable $@ represent?", options: ["First dependency", "All dependencies", "Target name", "Source file"], answer: 2 }],
    tools: [{ name: "Makefile Generator", type: "interactive", description: "Generate custom Makefiles" }]
};
