export const session13 = {
    title: "Stack and Heap Management",
    content: `<style>.firmware-lesson{padding:0;margin:0}.firmware-lesson h2{color:#e74c3c;margin-top:40px;margin-bottom:20px;font-size:1.8em;border-left:5px solid #e74c3c;padding-left:15px}.hero-box{background:linear-gradient(135deg,rgba(231,76,60,0.1) 0%,rgba(192,57,43,0.1) 100%);border-radius:15px;padding:30px;margin:30px 0;text-align:center;border:2px solid rgba(231,76,60,0.2)}.info-box{background:#f8f9fa;border-left:5px solid #e74c3c;padding:20px;margin:25px 0;border-radius:8px}.cards-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:20px;margin:25px 0}.info-card{background:linear-gradient(135deg,rgba(231,76,60,0.08) 0%,rgba(192,57,43,0.08) 100%);padding:25px;border-radius:12px;border:2px solid rgba(231,76,60,0.2);transition:all 0.3s ease}.info-card:hover{transform:translateY(-5px);box-shadow:0 10px 25px rgba(231,76,60,0.2)}.card-icon{font-size:50px;margin-bottom:15px;display:block}.info-card h4{color:#e74c3c;margin-bottom:10px;font-size:1.2em}.firmware-lesson p{color:#333;margin-bottom:15px;font-size:1.05em;line-height:1.7}.firmware-lesson ul{margin:15px 0 15px 25px}.code-box{background:#1e1e1e;color:#d4d4d4;padding:20px;border-radius:10px;margin:20px 0;font-family:monospace;overflow-x:auto;font-size:14px}.quiz-box{background:#fff9e6;padding:25px;border-radius:15px;margin-top:30px;border:3px solid #ffd700}.fun-fact{background:#e8f5e9;border-left:5px solid #4caf50;padding:20px;margin:25px 0;border-radius:8px}</style><div class="firmware-lesson"><div class="hero-box"><div style="font-size:60px;margin-bottom:15px">ğŸ“š</div><p>Stack and Heap: Managing dynamic memory in embedded systems!</p></div><h2>ğŸ¯ Stack vs Heap</h2><div class="cards-grid"><div class="info-card"><span class="card-icon">ğŸ“š</span><h4>Stack</h4><p>Automatic, fast, fixed size, LIFO</p></div><div class="info-card"><span class="card-icon">ğŸ—ƒï¸</span><h4>Heap</h4><p>Manual, slower, dynamic size, fragmentation</p></div></div><h2>ğŸ“š The Stack</h2><div class="info-box"><strong>Stack Usage:</strong><ul><li>Function call return addresses</li><li>Local variables</li><li>Function parameters</li><li>Saved registers during interrupts</li></ul></div><div class="code-box">/* Stack grows DOWNWARD from high to low addresses */<br><br>RAM (0x20000000 - 0x2001FFFF = 128KB)<br>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” 0x20000000<br>â”‚  .data           â”‚<br>â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤<br>â”‚  .bss            â”‚<br>â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤<br>â”‚  Heap â†“          â”‚ Grows upward<br>â”‚                  â”‚<br>â”‚                  â”‚<br>â”‚  Stack â†‘         â”‚ Grows downward<br>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ 0x20020000 (_estack)</div><h2>âš™ï¸ Stack Pointer Initialization</h2><div class="code-box">/* In linker script */<br>_estack = ORIGIN(RAM) + LENGTH(RAM);<br>/* _estack = 0x20000000 + 0x20000 = 0x20020000 */<br><br>/* In vector table */<br>__attribute__((section(".isr_vector")))<br>void (* const g_pfnVectors[])(void) = {<br>    (void (*)(void))((uint32_t)&_estack),  /* Initial SP */<br>    Reset_Handler,<br>    /* ... */<br>};<br><br>/* Hardware automatically loads SP from address 0x00 */</div><h2>ğŸ“Š Stack Usage Example</h2><div class="code-box">void function_b(int x, int y) {<br>    int result = x + y;  /* Local variable on stack */<br>    /* Stack: [result][y][x][return_addr] */<br>}<br><br>void function_a(void) {<br>    int a = 10;          /* Local on stack */<br>    function_b(5, 3);    /* Push params, call */<br>    /* Stack: [a][return_addr] */<br>}<br><br>int main(void) {<br>    function_a();<br>    /* Stack: [return_addr_to_startup] */<br>    return 0;<br>}</div><h2>âš ï¸ Stack Overflow Detection</h2><div class="code-box">/* Method 1: Fill stack with pattern */<br>extern uint32_t _sstack;  /* Start of stack */<br>extern uint32_t _estack;  /* End of stack */<br><br>#define STACK_FILL_PATTERN 0xDEADBEEF<br><br>void stack_init(void) {<br>    uint32_t *p = &_sstack;<br>    while (p < &_estack) {<br>        *p++ = STACK_FILL_PATTERN;<br>    }<br>}<br><br>uint32_t stack_usage(void) {<br>    uint32_t *p = &_sstack;<br>    uint32_t count = 0;<br>    <br>    while (*p == STACK_FILL_PATTERN && p < &_estack) {<br>        count++;<br>        p++;<br>    }<br>    <br>    return ((&_estack - &_sstack) - count) * 4;  /* Bytes used */<br>}</div><h2>ğŸ—ƒï¸ The Heap</h2><div class="info-box"><strong>Heap Usage:</strong><ul><li>Dynamic memory allocation (malloc)</li><li>Variable-sized data structures</li><li>Runtime-determined sizes</li><li>Long-lived objects</li></ul></div><div class="code-box">/* Heap placement in linker script */<br><br>_Min_Heap_Size = 0x200;  /* 512 bytes */<br><br>._user_heap_stack : {<br>    . = ALIGN(8);<br>    PROVIDE(end = .);<br>    PROVIDE(_end = .);<br>    _heap_start = .;<br>    . = . + _Min_Heap_Size;<br>    _heap_end = .;<br>    . = . + _Min_Stack_Size;<br>} > RAM</div><h2>ğŸ’¾ Simple Heap Implementation</h2><div class="code-box">/* Simple bump allocator (no free) */<br><br>extern uint32_t _heap_start;<br>extern uint32_t _heap_end;<br><br>static uint32_t *heap_ptr = &_heap_start;<br><br>void* malloc(size_t size) {<br>    void *ptr = NULL;<br>    <br>    /* Align to 8 bytes */<br>    size = (size + 7) & ~7;<br>    <br>    /* Check if enough space */<br>    if ((uint32_t)heap_ptr + size <= (uint32_t)&_heap_end) {<br>        ptr = heap_ptr;<br>        heap_ptr += size / 4;<br>    }<br>    <br>    return ptr;<br>}<br><br>void free(void *ptr) {<br>    /* Simple allocator doesn't support free */<br>    (void)ptr;<br>}</div><h2>ğŸ¯ _sbrk Implementation</h2><div class="code-box">/* _sbrk for newlib malloc */<br><br>#include <errno.h><br><br>extern uint32_t _end;  /* End of .bss */<br>extern uint32_t _estack;<br><br>void* _sbrk(int incr) {<br>    static uint8_t *heap_end = NULL;<br>    uint8_t *prev_heap_end;<br>    <br>    if (heap_end == NULL) {<br>        heap_end = (uint8_t*)&_end;<br>    }<br>    <br>    prev_heap_end = heap_end;<br>    <br>    /* Check collision with stack */<br>    if (heap_end + incr > (uint8_t*)__get_MSP()) {<br>        errno = ENOMEM;<br>        return (void*)-1;<br>    }<br>    <br>    heap_end += incr;<br>    return (void*)prev_heap_end;<br>}</div><h2>âš ï¸ Heap Fragmentation</h2><div class="code-box">/* Fragmentation example */<br><br>void* p1 = malloc(100);  /* [100 bytes used] */<br>void* p2 = malloc(100);  /* [100][100] */<br>void* p3 = malloc(100);  /* [100][100][100] */<br><br>free(p2);                /* [100][FREE][100] */<br><br>void* p4 = malloc(200);  /* FAILS! 200 bytes available but fragmented */<br><br>/* Solution: Use memory pools or avoid malloc in embedded */</div><h2>ğŸ¯ Stack Size Calculation</h2><div class="code-box">/* Calculate required stack size */<br><br>Stack = max_call_depth * (locals + saved_registers)<br><br>Example:<br>main() calls func_a() calls func_b()<br><br>main():   20 bytes locals<br>func_a(): 40 bytes locals<br>func_b(): 60 bytes locals<br>Saved regs: 32 bytes per call (8 registers Ã— 4 bytes)<br><br>Total = 20 + (40 + 32) + (60 + 32) = 184 bytes<br><br>/* Add margin for interrupts! */<br>Interrupt stack = 32 bytes (auto-saved) + ISR locals<br><br>/* Recommended: 2x calculated + 512 bytes margin */</div><h2>ğŸ’¡ Best Practices</h2><div class="info-box"><strong>Stack Best Practices:</strong><ul><li>Keep local variables small</li><li>Avoid deep recursion</li><li>Avoid large arrays on stack</li><li>Monitor stack usage in debug builds</li></ul><strong>Heap Best Practices:</strong><ul><li>Avoid malloc/free in embedded if possible</li><li>Use static allocation when size is known</li><li>Use memory pools for fixed-size objects</li><li>Never malloc in interrupts!</li></ul></div><div class="code-box">/* BAD: Large array on stack */<br>void bad_function(void) {<br>    uint8_t buffer[4096];  /* 4KB on stack! */<br>}<br><br>/* GOOD: Static allocation */<br>static uint8_t buffer[4096];<br>void good_function(void) {<br>    /* Use buffer */<br>}<br><br>/* GOOD: Heap allocation (if needed) */<br>void better_function(void) {<br>    uint8_t *buffer = malloc(4096);<br>    /* Use buffer */<br>    free(buffer);<br>}</div><div class="fun-fact"><strong>ğŸŒŸ Stack Speed:</strong><p style="margin-top:10px;margin-bottom:0">The stack is FAST! Allocating a local variable is just one instruction (subtract from SP). Heap allocation (malloc) can take hundreds of instructions. That's why embedded systems prefer stack and static allocation over dynamic allocation!</p></div><div class="quiz-box"><h3>ğŸ§  Test Your Knowledge!</h3><p><strong>Question:</strong> Which direction does the stack grow?</p><ul><li>A) Upward (low to high addresses)</li><li>B) Downward (high to low addresses) âœ“</li><li>C) Both directions</li><li>D) It doesn't grow</li></ul><p style="margin-top:15px"><em>Answer: B - Stack grows downward from high to low addresses!</em></p></div></div>`,
    questions: [{ q: "Which direction does the stack grow?", options: ["Upward (low to high addresses)", "Downward (high to low addresses)", "Both directions", "It doesn't grow"], answer: 1 }],
    tools: [{ name: "Stack Analyzer", type: "interactive", description: "Analyze stack usage" }]
};
