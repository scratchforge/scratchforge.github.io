export const session1 = {
    title: "Introduction to Embedded Firmware Development",
    content: `<style>.firmware-lesson{padding:0;margin:0}.firmware-lesson h2{color:#e74c3c;margin-top:40px;margin-bottom:20px;font-size:1.8em;border-left:5px solid #e74c3c;padding-left:15px}.hero-box{background:linear-gradient(135deg,rgba(231,76,60,0.1) 0%,rgba(192,57,43,0.1) 100%);border-radius:15px;padding:30px;margin:30px 0;text-align:center;border:2px solid rgba(231,76,60,0.2)}.info-box{background:#f8f9fa;border-left:5px solid #e74c3c;padding:20px;margin:25px 0;border-radius:8px}.cards-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:20px;margin:25px 0}.info-card{background:linear-gradient(135deg,rgba(231,76,60,0.08) 0%,rgba(192,57,43,0.08) 100%);padding:25px;border-radius:12px;border:2px solid rgba(231,76,60,0.2);transition:all 0.3s ease}.info-card:hover{transform:translateY(-5px);box-shadow:0 10px 25px rgba(231,76,60,0.2)}.card-icon{font-size:50px;margin-bottom:15px;display:block}.info-card h4{color:#e74c3c;margin-bottom:10px;font-size:1.2em}.firmware-lesson p{color:#333;margin-bottom:15px;font-size:1.05em;line-height:1.7}.firmware-lesson ul{margin:15px 0 15px 25px}.code-box{background:#1e1e1e;color:#d4d4d4;padding:20px;border-radius:10px;margin:20px 0;font-family:monospace;overflow-x:auto;font-size:14px}.quiz-box{background:#fff9e6;padding:25px;border-radius:15px;margin-top:30px;border:3px solid #ffd700}.fun-fact{background:#e8f5e9;border-left:5px solid #4caf50;padding:20px;margin:25px 0;border-radius:8px}</style><div class="firmware-lesson"><div class="hero-box"><div style="font-size:60px;margin-bottom:15px">ğŸ”§</div><p>Embedded Firmware Development: Building software that talks directly to hardware!</p></div><h2>ğŸ¯ What is Bare-Metal Programming?</h2><p><strong>Bare-metal programming</strong> means writing code that runs directly on the microcontroller hardware without an operating system. You control every aspect of the hardware - from the first instruction after power-on to how peripherals are configured.</p><div class="cards-grid"><div class="info-card"><span class="card-icon">âš™ï¸</span><h4>Direct Hardware Control</h4><p>No OS layer - you program registers directly</p></div><div class="info-card"><span class="card-icon">ğŸš€</span><h4>Maximum Performance</h4><p>Zero overhead, deterministic timing</p></div><div class="info-card"><span class="card-icon">ğŸ’¾</span><h4>Minimal Footprint</h4><p>Code fits in tiny memory spaces</p></div><div class="info-card"><span class="card-icon">ğŸ“</span><h4>Deep Understanding</h4><p>Learn how everything really works</p></div></div><h2>ğŸ†š Firmware vs Software</h2><div class="info-box"><strong>Software (Application):</strong><ul><li>Runs on an operating system (Windows, Linux, etc.)</li><li>Uses high-level APIs and libraries</li><li>OS handles hardware abstraction</li><li>Example: Web browser, text editor</li></ul><strong>Firmware (Embedded):</strong><ul><li>Runs directly on hardware (bare-metal)</li><li>You write the low-level drivers</li><li>Direct register manipulation</li><li>Example: Microwave controller, car ECU</li></ul></div><h2>ğŸ› ï¸ Development Without IDEs</h2><p>In this course, we'll build firmware using only command-line tools. This gives you complete control and understanding of the build process.</p><div class="cards-grid"><div class="info-card"><span class="card-icon">ğŸ”¨</span><h4>GCC Compiler</h4><p>arm-none-eabi-gcc for ARM Cortex-M</p></div><div class="info-card"><span class="card-icon">ğŸ“</span><h4>Text Editor</h4><p>VS Code, Vim, or any editor you like</p></div><div class="info-card"><span class="card-icon">ğŸ”—</span><h4>Make</h4><p>Build automation tool</p></div><div class="info-card"><span class="card-icon">ğŸ›</span><h4>GDB + OpenOCD</h4><p>Debugging and flashing</p></div></div><h2>ğŸ“š Our Toolchain Stack</h2><div class="code-box"># Complete toolchain we'll use:<br><br>1. ARM GCC Toolchain<br>   â””â”€ arm-none-eabi-gcc (compiler)<br>   â””â”€ arm-none-eabi-ld (linker)<br>   â””â”€ arm-none-eabi-objcopy (binary converter)<br>   â””â”€ arm-none-eabi-objdump (disassembler)<br>   â””â”€ arm-none-eabi-gdb (debugger)<br><br>2. GNU Make<br>   â””â”€ Build automation<br><br>3. OpenOCD<br>   â””â”€ On-chip debugger<br>   â””â”€ Flash programmer<br><br>4. ST-Link / J-Link<br>   â””â”€ Hardware debugger probe</div><h2>ğŸ¯ What You'll Learn</h2><div class="info-box"><strong>By the end of this course, you'll be able to:</strong><ul><li>âœ… Write complete firmware from scratch (no IDE)</li><li>âœ… Create custom linker scripts</li><li>âœ… Write startup code and vector tables</li><li>âœ… Understand memory layout (.text, .data, .bss)</li><li>âœ… Program peripherals using pointers</li><li>âœ… Configure clocks and GPIO from registers</li><li>âœ… Build with Makefiles</li><li>âœ… Debug with GDB and OpenOCD</li><li>âœ… Flash custom firmware to MCU</li><li>âœ… Build production-ready embedded projects</li></ul></div><h2>ğŸ—ï¸ Course Structure</h2><div class="cards-grid"><div class="info-card"><span class="card-icon">1ï¸âƒ£</span><h4>Foundation (1-5)</h4><p>MCU architecture, toolchain, ELF files</p></div><div class="info-card"><span class="card-icon">2ï¸âƒ£</span><h4>Build System (6-10)</h4><p>GCC, Make, linker scripts, sections</p></div><div class="info-card"><span class="card-icon">3ï¸âƒ£</span><h4>Startup (11-15)</h4><p>Vector table, reset handler, boot process</p></div><div class="info-card"><span class="card-icon">4ï¸âƒ£</span><h4>Hardware (16-20)</h4><p>MMIO, pointers, GPIO, clocks, UART</p></div><div class="info-card"><span class="card-icon">5ï¸âƒ£</span><h4>Advanced (21-25)</h4><p>Flashing, debugging, interrupts, DMA</p></div></div><h2>ğŸ’» Example: Hello World (Bare-Metal)</h2><div class="code-box">// Traditional "Hello World" with printf<br>int main(void) {<br>    printf("Hello World\\n");<br>    return 0;<br>}<br><br>// Bare-metal "Hello World" - blink LED<br>#define RCC_AHB1ENR   (*(volatile uint32_t*)0x40023830)<br>#define GPIOA_MODER   (*(volatile uint32_t*)0x40020000)<br>#define GPIOA_ODR     (*(volatile uint32_t*)0x40020014)<br><br>int main(void) {<br>    RCC_AHB1ENR |= (1 << 0);      // Enable GPIOA clock<br>    GPIOA_MODER |= (1 << 10);     // Set PA5 as output<br>    <br>    while(1) {<br>        GPIOA_ODR ^= (1 << 5);    // Toggle PA5<br>        for(int i=0; i<100000; i++); // Delay<br>    }<br>}</div><div class="info-box"><strong>âš ï¸ Key Differences:</strong><ul><li><strong>No printf:</strong> You must implement UART yourself</li><li><strong>Direct register access:</strong> Using memory addresses</li><li><strong>Volatile keyword:</strong> Prevents compiler optimization</li><li><strong>Infinite loop:</strong> Embedded programs never exit</li></ul></div><div class="fun-fact"><strong>ğŸŒŸ Industry Reality:</strong><p style="margin-top:10px;margin-bottom:0">Most professional embedded developers use IDEs, but understanding the underlying toolchain makes you a 10x better engineer. When things break (and they will), you'll know exactly what's happening under the hood!</p></div><div class="quiz-box"><h3>ğŸ§  Test Your Knowledge!</h3><p><strong>Question:</strong> What does "bare-metal" programming mean?</p><ul><li>A) Programming in assembly language</li><li>B) Programming without an operating system âœ“</li><li>C) Programming hardware drivers</li><li>D) Programming in C only</li></ul><p style="margin-top:15px"><em>Answer: B - Bare-metal means running code directly on hardware without an OS!</em></p></div></div>`,
    questions: [{ q: "What does 'bare-metal' programming mean?", options: ["Programming in assembly language", "Programming without an operating system", "Programming hardware drivers", "Programming in C only"], answer: 1 }],
    tools: [{ name: "Toolchain Setup Guide", type: "interactive", description: "Step-by-step toolchain installation" }]
};
