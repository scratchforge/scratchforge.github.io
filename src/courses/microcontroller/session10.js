export const session10 = {
    title: "Real-Time Operating Systems (RTOS)",
    content: `<style>.microcontroller-lesson{padding:0;margin:0}.microcontroller-lesson h2{color:#667eea;margin-top:40px;margin-bottom:20px;font-size:1.8em;border-left:5px solid #667eea;padding-left:15px}.hero-box{background:linear-gradient(135deg,rgba(102,126,234,0.1) 0%,rgba(118,75,162,0.1) 100%);border-radius:15px;padding:30px;margin:30px 0;text-align:center;border:2px solid rgba(102,126,234,0.2)}.info-box{background:#f8f9fa;border-left:5px solid #667eea;padding:20px;margin:25px 0;border-radius:8px}.cards-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:20px;margin:25px 0}.info-card{background:linear-gradient(135deg,rgba(102,126,234,0.08) 0%,rgba(118,75,162,0.08) 100%);padding:25px;border-radius:12px;border:2px solid rgba(102,126,234,0.2);transition:all 0.3s ease}.info-card:hover{transform:translateY(-5px);box-shadow:0 10px 25px rgba(102,126,234,0.2)}.card-icon{font-size:50px;margin-bottom:15px;display:block}.info-card h4{color:#667eea;margin-bottom:10px;font-size:1.2em}.microcontroller-lesson p{color:#333;margin-bottom:15px;font-size:1.05em;line-height:1.7}.microcontroller-lesson ul{margin:15px 0 15px 25px}.quiz-box{background:#fff9e6;padding:25px;border-radius:15px;margin-top:30px;border:3px solid #ffd700}.fun-fact{background:#e8f5e9;border-left:5px solid #4caf50;padding:20px;margin:25px 0;border-radius:8px}.code-box{background:#1e1e1e;color:#d4d4d4;padding:20px;border-radius:10px;margin:20px 0;font-family:monospace;overflow-x:auto}</style><div class="microcontroller-lesson"><div class="hero-box"><div style="font-size:60px;margin-bottom:15px">‚öôÔ∏è</div><p>RTOS: Real-Time Operating Systems - Multitasking for microcontrollers!</p></div><h2>üéØ What is an RTOS?</h2><p>A Real-Time Operating System (RTOS) allows your microcontroller to run multiple tasks concurrently with guaranteed timing. Instead of a single loop(), you can have multiple tasks running "simultaneously" with precise scheduling!</p><div class="cards-grid"><div class="info-card"><span class="card-icon">üîÑ</span><h4>Multitasking</h4><p>Run multiple tasks concurrently</p></div><div class="info-card"><span class="card-icon">‚è±Ô∏è</span><h4>Deterministic</h4><p>Guaranteed response times</p></div><div class="info-card"><span class="card-icon">üìä</span><h4>Priority-Based</h4><p>High-priority tasks run first</p></div><div class="info-card"><span class="card-icon">üîí</span><h4>Resource Management</h4><p>Semaphores, mutexes, queues</p></div></div><h2>üÜö RTOS vs Bare Metal</h2><div class="info-box"><strong>Bare Metal (Traditional Arduino):</strong><ul><li>Single loop() function</li><li>Manual task scheduling</li><li>Simple but limited</li><li>Good for simple projects</li></ul><strong>RTOS:</strong><ul><li>Multiple concurrent tasks</li><li>Automatic scheduling</li><li>More complex but powerful</li><li>Better for complex projects</li></ul></div><div class="code-box">// FreeRTOS Example - Multiple Tasks<br>#include &lt;Arduino_FreeRTOS.h&gt;<br><br>void TaskBlink(void *pvParameters);<br>void TaskSerial(void *pvParameters);<br><br>void setup() {<br>&nbsp;&nbsp;Serial.begin(9600);<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;// Create tasks<br>&nbsp;&nbsp;xTaskCreate(<br>&nbsp;&nbsp;&nbsp;&nbsp;TaskBlink,   // Function<br>&nbsp;&nbsp;&nbsp;&nbsp;"Blink",     // Name<br>&nbsp;&nbsp;&nbsp;&nbsp;128,         // Stack size<br>&nbsp;&nbsp;&nbsp;&nbsp;NULL,        // Parameters<br>&nbsp;&nbsp;&nbsp;&nbsp;2,           // Priority<br>&nbsp;&nbsp;&nbsp;&nbsp;NULL);       // Task handle<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;xTaskCreate(<br>&nbsp;&nbsp;&nbsp;&nbsp;TaskSerial,<br>&nbsp;&nbsp;&nbsp;&nbsp;"Serial",<br>&nbsp;&nbsp;&nbsp;&nbsp;128,<br>&nbsp;&nbsp;&nbsp;&nbsp;NULL,<br>&nbsp;&nbsp;&nbsp;&nbsp;1,           // Lower priority<br>&nbsp;&nbsp;&nbsp;&nbsp;NULL);<br>}<br><br>void loop() {<br>&nbsp;&nbsp;// Empty - tasks run automatically<br>}<br><br>void TaskBlink(void *pvParameters) {<br>&nbsp;&nbsp;pinMode(LED_BUILTIN, OUTPUT);<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;for (;;) { // Infinite loop<br>&nbsp;&nbsp;&nbsp;&nbsp;digitalWrite(LED_BUILTIN, HIGH);<br>&nbsp;&nbsp;&nbsp;&nbsp;vTaskDelay(500 / portTICK_PERIOD_MS);<br>&nbsp;&nbsp;&nbsp;&nbsp;digitalWrite(LED_BUILTIN, LOW);<br>&nbsp;&nbsp;&nbsp;&nbsp;vTaskDelay(500 / portTICK_PERIOD_MS);<br>&nbsp;&nbsp;}<br>}<br><br>void TaskSerial(void *pvParameters) {<br>&nbsp;&nbsp;for (;;) {<br>&nbsp;&nbsp;&nbsp;&nbsp;Serial.println("Task running...");<br>&nbsp;&nbsp;&nbsp;&nbsp;vTaskDelay(1000 / portTICK_PERIOD_MS);<br>&nbsp;&nbsp;}<br>}</div><h2>üì¨ Inter-Task Communication</h2><div class="code-box">// Queue Example - Pass data between tasks<br>#include &lt;Arduino_FreeRTOS.h&gt;<br>#include &lt;queue.h&gt;<br><br>QueueHandle_t sensorQueue;<br><br>void TaskReadSensor(void *pvParameters) {<br>&nbsp;&nbsp;for (;;) {<br>&nbsp;&nbsp;&nbsp;&nbsp;int sensorValue = analogRead(A0);<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;// Send to queue<br>&nbsp;&nbsp;&nbsp;&nbsp;xQueueSend(sensorQueue, &sensorValue, portMAX_DELAY);<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;vTaskDelay(100 / portTICK_PERIOD_MS);<br>&nbsp;&nbsp;}<br>}<br><br>void TaskProcessData(void *pvParameters) {<br>&nbsp;&nbsp;int receivedValue;<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;for (;;) {<br>&nbsp;&nbsp;&nbsp;&nbsp;// Receive from queue<br>&nbsp;&nbsp;&nbsp;&nbsp;if (xQueueReceive(sensorQueue, &receivedValue,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;portMAX_DELAY) == pdPASS) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Serial.print("Processed: ");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Serial.println(receivedValue);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>}<br><br>void setup() {<br>&nbsp;&nbsp;Serial.begin(9600);<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;// Create queue (10 items, int size)<br>&nbsp;&nbsp;sensorQueue = xQueueCreate(10, sizeof(int));<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;xTaskCreate(TaskReadSensor, "Read", 128, NULL, 2, NULL);<br>&nbsp;&nbsp;xTaskCreate(TaskProcessData, "Process", 128, NULL, 1, NULL);<br>}</div><h2>üîí Semaphores and Mutexes</h2><div class="code-box">// Mutex Example - Protect shared resource<br>#include &lt;Arduino_FreeRTOS.h&gt;<br>#include &lt;semphr.h&gt;<br><br>SemaphoreHandle_t serialMutex;<br><br>void TaskA(void *pvParameters) {<br>&nbsp;&nbsp;for (;;) {<br>&nbsp;&nbsp;&nbsp;&nbsp;// Take mutex<br>&nbsp;&nbsp;&nbsp;&nbsp;if (xSemaphoreTake(serialMutex, portMAX_DELAY)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Serial.println("Task A writing...");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delay(100);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Give mutex back<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xSemaphoreGive(serialMutex);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;vTaskDelay(500 / portTICK_PERIOD_MS);<br>&nbsp;&nbsp;}<br>}<br><br>void TaskB(void *pvParameters) {<br>&nbsp;&nbsp;for (;;) {<br>&nbsp;&nbsp;&nbsp;&nbsp;if (xSemaphoreTake(serialMutex, portMAX_DELAY)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Serial.println("Task B writing...");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delay(100);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xSemaphoreGive(serialMutex);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;vTaskDelay(500 / portTICK_PERIOD_MS);<br>&nbsp;&nbsp;}<br>}<br><br>void setup() {<br>&nbsp;&nbsp;Serial.begin(9600);<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;// Create mutex<br>&nbsp;&nbsp;serialMutex = xSemaphoreCreateMutex();<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;xTaskCreate(TaskA, "A", 128, NULL, 1, NULL);<br>&nbsp;&nbsp;xTaskCreate(TaskB, "B", 128, NULL, 1, NULL);<br>}</div><h2>üéØ Popular RTOS Options</h2><div class="cards-grid"><div class="info-card"><span class="card-icon">üÜì</span><h4>FreeRTOS</h4><p>Most popular, open-source, well-documented</p></div><div class="info-card"><span class="card-icon">‚ö°</span><h4>Zephyr</h4><p>Modern, Linux Foundation, IoT-focused</p></div><div class="info-card"><span class="card-icon">üîß</span><h4>RIOT</h4><p>Lightweight, IoT-oriented, modular</p></div><div class="info-card"><span class="card-icon">üè¢</span><h4>ThreadX</h4><p>Commercial, certified, safety-critical</p></div></div><div class="info-box"><strong>‚ö†Ô∏è When to Use RTOS:</strong><ul><li><strong>Complex timing:</strong> Multiple tasks with different schedules</li><li><strong>Real-time requirements:</strong> Guaranteed response times needed</li><li><strong>Resource sharing:</strong> Multiple tasks accessing shared resources</li><li><strong>Scalability:</strong> Project will grow in complexity</li></ul><strong>When NOT to use RTOS:</strong><ul><li>Simple projects with one main loop</li><li>Limited RAM (RTOS adds overhead)</li><li>Learning basics (start simple first!)</li></ul></div><div class="fun-fact"><strong>üåü Industry Usage:</strong><p style="margin-top:10px;margin-bottom:0">RTOS is used in critical systems everywhere: automotive (engine control), aerospace (flight computers), medical devices (pacemakers), and industrial automation. FreeRTOS alone powers over 40 microcontroller architectures!</p></div><div class="quiz-box"><h3>üß† Test Your Knowledge!</h3><p><strong>Question:</strong> What is the main advantage of using an RTOS?</p><ul><li>A) Faster code execution</li><li>B) Less memory usage</li><li>C) Concurrent tasks with guaranteed timing ‚úì</li><li>D) Easier to learn</li></ul><p style="margin-top:15px"><em>Answer: C - RTOS enables multitasking with deterministic, guaranteed response times!</em></p></div></div>`,
    questions: [{ q: "What is the main advantage of using an RTOS?", options: ["Faster code execution", "Less memory usage", "Concurrent tasks with guaranteed timing", "Easier to learn"], answer: 2 }],
    tools: [{ name: "RTOS Scheduler", type: "interactive", description: "Visualize task scheduling" }]
};
