export const session3 = {
    title: "Timers and Interrupts",
    content: `<style>.microcontroller-lesson{padding:0;margin:0}.microcontroller-lesson h2{color:#667eea;margin-top:40px;margin-bottom:20px;font-size:1.8em;border-left:5px solid #667eea;padding-left:15px}.hero-box{background:linear-gradient(135deg,rgba(102,126,234,0.1) 0%,rgba(118,75,162,0.1) 100%);border-radius:15px;padding:30px;margin:30px 0;text-align:center;border:2px solid rgba(102,126,234,0.2)}.info-box{background:#f8f9fa;border-left:5px solid #667eea;padding:20px;margin:25px 0;border-radius:8px}.cards-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:20px;margin:25px 0}.info-card{background:linear-gradient(135deg,rgba(102,126,234,0.08) 0%,rgba(118,75,162,0.08) 100%);padding:25px;border-radius:12px;border:2px solid rgba(102,126,234,0.2);transition:all 0.3s ease}.info-card:hover{transform:translateY(-5px);box-shadow:0 10px 25px rgba(102,126,234,0.2)}.card-icon{font-size:50px;margin-bottom:15px;display:block}.info-card h4{color:#667eea;margin-bottom:10px;font-size:1.2em}.microcontroller-lesson p{color:#333;margin-bottom:15px;font-size:1.05em;line-height:1.7}.microcontroller-lesson ul{margin:15px 0 15px 25px}.quiz-box{background:#fff9e6;padding:25px;border-radius:15px;margin-top:30px;border:3px solid #ffd700}.fun-fact{background:#e8f5e9;border-left:5px solid #4caf50;padding:20px;margin:25px 0;border-radius:8px}.code-box{background:#1e1e1e;color:#d4d4d4;padding:20px;border-radius:10px;margin:20px 0;font-family:monospace;overflow-x:auto}</style><div class="microcontroller-lesson"><div class="hero-box"><div style="font-size:60px;margin-bottom:15px">‚è±Ô∏è</div><p>Timers and Interrupts: Precise timing and responsive event handling!</p></div><h2>‚è∞ Hardware Timers</h2><p>Hardware timers are independent counters that run in the background, allowing precise timing without blocking your main program. Most microcontrollers have multiple timers with different capabilities.</p><div class="cards-grid"><div class="info-card"><span class="card-icon">üî¢</span><h4>Counter Mode</h4><p>Count external events or clock cycles</p></div><div class="info-card"><span class="card-icon">‚è≤Ô∏è</span><h4>Timer Mode</h4><p>Generate precise time delays and intervals</p></div><div class="info-card"><span class="card-icon">üìä</span><h4>PWM Mode</h4><p>Generate pulse-width modulated signals</p></div><div class="info-card"><span class="card-icon">üì∏</span><h4>Capture Mode</h4><p>Measure external signal timing</p></div></div><h2>‚ö° Interrupts - Event-Driven Programming</h2><p>Interrupts allow your microcontroller to respond immediately to important events without constantly checking (polling). When an interrupt occurs, the CPU pauses its current task, executes an interrupt service routine (ISR), then returns.</p><div class="code-box">// Timer Interrupt Example (Arduino)<br>volatile int counter = 0;<br><br>void setup() {<br>&nbsp;&nbsp;Serial.begin(9600);<br>&nbsp;&nbsp;// Configure Timer1 for 1Hz interrupt<br>&nbsp;&nbsp;cli(); // Disable interrupts<br>&nbsp;&nbsp;TCCR1A = 0;<br>&nbsp;&nbsp;TCCR1B = 0;<br>&nbsp;&nbsp;TCNT1 = 0;<br>&nbsp;&nbsp;OCR1A = 15624; // 1Hz at 16MHz/1024 prescaler<br>&nbsp;&nbsp;TCCR1B |= (1 << WGM12); // CTC mode<br>&nbsp;&nbsp;TCCR1B |= (1 << CS12) | (1 << CS10); // 1024 prescaler<br>&nbsp;&nbsp;TIMSK1 |= (1 << OCIE1A); // Enable interrupt<br>&nbsp;&nbsp;sei(); // Enable interrupts<br>}<br><br>ISR(TIMER1_COMPA_vect) {<br>&nbsp;&nbsp;counter++;<br>&nbsp;&nbsp;Serial.println(counter);<br>}</div><h2>üéØ External Interrupts</h2><div class="code-box">// External Interrupt Example<br>const int buttonPin = 2; // INT0 on most Arduinos<br>volatile bool buttonPressed = false;<br><br>void setup() {<br>&nbsp;&nbsp;pinMode(buttonPin, INPUT_PULLUP);<br>&nbsp;&nbsp;attachInterrupt(digitalPinToInterrupt(buttonPin),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buttonISR, FALLING);<br>}<br><br>void buttonISR() {<br>&nbsp;&nbsp;buttonPressed = true; // Set flag<br>}<br><br>void loop() {<br>&nbsp;&nbsp;if (buttonPressed) {<br>&nbsp;&nbsp;&nbsp;&nbsp;// Handle button press<br>&nbsp;&nbsp;&nbsp;&nbsp;buttonPressed = false;<br>&nbsp;&nbsp;}<br>}</div><div class="info-box"><strong>‚ö†Ô∏è ISR Best Practices:</strong><ul><li><strong>Keep it SHORT:</strong> ISRs should execute quickly</li><li><strong>No delays:</strong> Don't use delay() in ISRs</li><li><strong>Volatile variables:</strong> Use 'volatile' for shared variables</li><li><strong>Minimal processing:</strong> Set flags, read values, then exit</li><li><strong>No Serial.print:</strong> Avoid in ISRs (can cause issues)</li></ul></div><div class="fun-fact"><strong>üåü Did You Know?</strong><p style="margin-top:10px;margin-bottom:0">Interrupts have priority levels! If multiple interrupts occur simultaneously, the CPU handles them based on priority. Some microcontrollers support nested interrupts, where higher-priority interrupts can interrupt lower-priority ISRs!</p></div><div class="quiz-box"><h3>üß† Test Your Knowledge!</h3><p><strong>Question:</strong> Why should you use the 'volatile' keyword for variables shared between ISRs and main code?</p><ul><li>A) It makes the code run faster</li><li>B) It prevents compiler optimization that could cause issues ‚úì</li><li>C) It's required for all global variables</li><li>D) It saves memory</li></ul><p style="margin-top:15px"><em>Answer: B - 'volatile' tells the compiler the variable can change unexpectedly, preventing optimizations that assume it won't!</em></p></div></div>`,
    questions: [{ q: "Why should you use the 'volatile' keyword for variables shared between ISRs and main code?", options: ["It makes the code run faster", "It prevents compiler optimization that could cause issues", "It's required for all global variables", "It saves memory"], answer: 1 }],
    tools: [{ name: "Timer Calculator", type: "interactive", description: "Calculate timer prescaler values" }]
};
